<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/team-gryff/react-monocle#readme"

    >react-monocle (v0.1.6)</a>
</h1>
<h4>A developer tool to visualize a React application's component hierarchy.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle">module react-monocle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery">
            function <span class="apidocSignatureSpan">react-monocle.</span>esquery
            <span class="apidocSignatureSpan">(ast, selector)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>esrecurse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>estraverse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>previewParser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>reactParser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>stringRegexHelper</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.esquery">module react-monocle.esquery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.esquery">
            function <span class="apidocSignatureSpan">react-monocle.</span>esquery
            <span class="apidocSignatureSpan">(ast, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.match">
            function <span class="apidocSignatureSpan">react-monocle.esquery.</span>match
            <span class="apidocSignatureSpan">(ast, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.matches">
            function <span class="apidocSignatureSpan">react-monocle.esquery.</span>matches
            <span class="apidocSignatureSpan">(node, selector, ancestry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.parse">
            function <span class="apidocSignatureSpan">react-monocle.esquery.</span>parse
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.query">
            function <span class="apidocSignatureSpan">react-monocle.esquery.</span>query
            <span class="apidocSignatureSpan">(ast, selector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.esrecurse">module react-monocle.esrecurse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esrecurse.Visitor">
            function <span class="apidocSignatureSpan">react-monocle.esrecurse.</span>Visitor
            <span class="apidocSignatureSpan">(visitor, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esrecurse.visit">
            function <span class="apidocSignatureSpan">react-monocle.esrecurse.</span>visit
            <span class="apidocSignatureSpan">(node, visitor, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.estraverse">module react-monocle.estraverse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.Controller">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>Controller
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.attachComments">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>attachComments
            <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.cloneEnvironment">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>cloneEnvironment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.replace">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>replace
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.traverse">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>traverse
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.estraverse.</span>Syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.estraverse.</span>VisitorKeys</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.estraverse.</span>VisitorOption</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-monocle.estraverse.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.parser">module react-monocle.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.parser.SyntaxError">
            function <span class="apidocSignatureSpan">react-monocle.parser.</span>SyntaxError
            <span class="apidocSignatureSpan">(expected, found, offset, line, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.parser.parse">
            function <span class="apidocSignatureSpan">react-monocle.parser.</span>parse
            <span class="apidocSignatureSpan">(input, startRule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.parser.toSource">
            function <span class="apidocSignatureSpan">react-monocle.parser.</span>toSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.previewParser">module react-monocle.previewParser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.getComponentName">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>getComponentName
            <span class="apidocSignatureSpan">(bundle, startingIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.getDivs">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>getDivs
            <span class="apidocSignatureSpan">(modifiedBundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.modifyBundleFile">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyBundleFile
            <span class="apidocSignatureSpan">(bundlejs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.modifyInitialState">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyInitialState
            <span class="apidocSignatureSpan">(modifiedBundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.modifySetStateStrings">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifySetStateStrings
            <span class="apidocSignatureSpan">(bundleFilePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.modifyTestBundleFile">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyTestBundleFile
            <span class="apidocSignatureSpan">(bundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.queryES5Ast">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>queryES5Ast
            <span class="apidocSignatureSpan">(bundlejs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.queryES6Ast">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>queryES6Ast
            <span class="apidocSignatureSpan">(bundlejs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.structureInitialES5StateObj">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>structureInitialES5StateObj
            <span class="apidocSignatureSpan">(bundle, arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.structureInitialES6StateObj">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>structureInitialES6StateObj
            <span class="apidocSignatureSpan">(bundle, arr)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.reactParser">module react-monocle.reactParser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.componentChecker">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>componentChecker
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.forInFinder">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>forInFinder
            <span class="apidocSignatureSpan">(arr, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.forLoopFinder">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>forLoopFinder
            <span class="apidocSignatureSpan">(arr, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.getES5ReactComponents">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getES5ReactComponents
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.getES6ReactComponents">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getES6ReactComponents
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.getStatelessFunctionalComponents">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getStatelessFunctionalComponents
            <span class="apidocSignatureSpan">(ast, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.higherOrderFunctionFinder">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>higherOrderFunctionFinder
            <span class="apidocSignatureSpan">(arr, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.jsToAst">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>jsToAst
            <span class="apidocSignatureSpan">(js)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.stringRegexHelper">module react-monocle.stringRegexHelper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.stringRegexHelper.regexIndexOf">
            function <span class="apidocSignatureSpan">react-monocle.stringRegexHelper.</span>regexIndexOf
            <span class="apidocSignatureSpan">(string, regex, startpos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.stringRegexHelper.regexLastIndexOf">
            function <span class="apidocSignatureSpan">react-monocle.stringRegexHelper.</span>regexLastIndexOf
            <span class="apidocSignatureSpan">(string, regex, startpos)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle" id="apidoc.module.react-monocle">module react-monocle</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.esquery" id="apidoc.element.react-monocle.esquery">
        function <span class="apidocSignatureSpan">react-monocle.</span>esquery
        <span class="apidocSignatureSpan">(ast, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(ast, selector) {
    return match(ast, parse(selector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.esquery" id="apidoc.module.react-monocle.esquery">module react-monocle.esquery</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.esquery.esquery" id="apidoc.element.react-monocle.esquery.esquery">
        function <span class="apidocSignatureSpan">react-monocle.</span>esquery
        <span class="apidocSignatureSpan">(ast, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(ast, selector) {
    return match(ast, parse(selector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esquery.match" id="apidoc.element.react-monocle.esquery.match">
        function <span class="apidocSignatureSpan">react-monocle.esquery.</span>match
        <span class="apidocSignatureSpan">(ast, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(ast, selector) {
    var ancestry = [], results = [], altSubjects, i, l, k, m;
    if (!selector) { return results; }
    altSubjects = subjects(selector);
    estraverse.traverse(ast, {
        enter: function (node, parent) {
            if (parent != null) { ancestry.unshift(parent); }
            if (matches(node, selector, ancestry)) {
                if (altSubjects.length) {
                    for (i = 0, l = altSubjects.length; i &#x3c; l; ++i) {
                        if (matches(node, altSubjects[i], ancestry)) { results.push(node); }
                        for (k = 0, m = ancestry.length; k &#x3c; m; ++k) {
                            if (matches(ancestry[k], altSubjects[i], ancestry.slice(k + 1))) {
                                results.push(ancestry[k]);
                            }
                        }
                    }
                } else {+
                    results.push(node);
                }
            }
        },
        leave: function () { ancestry.shift(); }
    });
    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
result.css = findCSS(stringed, path.replace(/\/.*?\.html/, &#x27;&#x27;).replace(/\/?.*?\.html/, &#x27;&#x27;));

return result;
}

function findCSS(str, relPath) {
if (relPath !== &#x27;&#x27;) relPath = relPath + &#x27;/&#x27;;
const styleTags = str.<span class="apidocCodeKeywordSpan">match</span>(/&#x3c;style&#x3e;(\n|.)*?(&#x3c;\/style&#x3e;)/g) || [&#
x27;&#x27;];
const cssLinks = str.match(/&#x3c;link.*?css.*?&#x3e;/g);
if (!cssLinks &#x26;&#x26; !styleTags) return [];
if (!cssLinks) return styleTags;
return cssLinks.map(ele =&#x3e; {
  if (!ele) return;
  if (ele.search(/http/) !== -1) return ele;
  if (ele.search(/href(\s?)=(\s?)(\\?)(&#x27;|&#x22;)\/{2}/)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esquery.matches" id="apidoc.element.react-monocle.esquery.matches">
        function <span class="apidocSignatureSpan">react-monocle.esquery.</span>matches
        <span class="apidocSignatureSpan">(node, selector, ancestry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matches(node, selector, ancestry) {
    var path, ancestor, i, l, p;
    if (!selector) { return true; }
    if (!node) { return false; }
    if (!ancestry) { ancestry = []; }

    switch(selector.type) {
        case &#x27;wildcard&#x27;:
            return true;

        case &#x27;identifier&#x27;:
            return selector.value.toLowerCase() === node.type.toLowerCase();

        case &#x27;field&#x27;:
            path = selector.name.split(&#x27;.&#x27;);
            ancestor = ancestry[path.length - 1];
            return inPath(node, ancestor, path);

        case &#x27;matches&#x27;:
            for (i = 0, l = selector.selectors.length; i &#x3c; l; ++i) {
                if (matches(node, selector.selectors[i], ancestry)) { return true; }
            }
            return false;

        case &#x27;compound&#x27;:
            for (i = 0, l = selector.selectors.length; i &#x3c; l; ++i) {
                if (!matches(node, selector.selectors[i], ancestry)) { return false; }
            }
            return true;

        case &#x27;not&#x27;:
            for (i = 0, l = selector.selectors.length; i &#x3c; l; ++i) {
                if (matches(node, selector.selectors[i], ancestry)) { return false; }
            }
            return true;

        case &#x27;child&#x27;:
            if (matches(node, selector.right, ancestry)) {
                return matches(ancestry[0], selector.left, ancestry.slice(1));
            }
            return false;

        case &#x27;descendant&#x27;:
            if (matches(node, selector.right, ancestry)) {
                for (i = 0, l = ancestry.length; i &#x3c; l; ++i) {
                    if (matches(ancestry[i], selector.left, ancestry.slice(i + 1))) {
                        return true;
                    }
                }
            }
            return false;

        case &#x27;attribute&#x27;:
            p = getPath(node, selector.name);
            switch (selector.operator) {
                case null:
                case void 0:
                    return p != null;
                case &#x27;=&#x27;:
                    switch (selector.value.type) {
                        case &#x27;regexp&#x27;: return selector.value.value.test(p);
                        case &#x27;literal&#x27;: return &#x27;&#x27; + selector.value.value === &#x27;&#x27; + p;
                        case &#x27;type&#x27;: return selector.value.value === typeof p;
                    }
                case &#x27;!=&#x27;:
                    switch (selector.value.type) {
                        case &#x27;regexp&#x27;: return !selector.value.value.test(p);
                        case &#x27;literal&#x27;: return &#x27;&#x27; + selector.value.value !== &#x27;&#x27; + p;
                        case &#x27;type&#x27;: return selector.value.value !== typeof p;
                    }
                case &#x27;&#x3c;=&#x27;: return p &#x3c;= selector.value.value;
                case &#x27;&#x3c;&#x27;: return p &#x3c; selector.value.value;
                case &#x27;&#x3e;&#x27;: return p &#x3e; selector.value.value;
                case &#x27;&#x3e;=&#x27;: return p &#x3e;= selector.value.value;
            }

        case &#x27;sibling&#x27;:
            return matches(node, selector.right, ancestry) &#x26;&#x26;
                sibling(node, selector.left, ancestry) ||
                matches(node, selector.left, ancestry) &#x26;&#x26;
                sibling(node, selector.right, ancestry);

        case &#x27;adjacent&#x27;:
            return matches(node, selector.right, ancestry) &#x26;&#x26;
                adjacent(node, selector.left, ancestry) ||
                matches(node, selector.left, ancestry) &#x26;&#x26;
                adjacent(node, selector.right, ancestry);

        case &#x27;nth-child&#x27;:
            return matches(node, selector.right, ancestry) &#x26;&#x26;
                nthChild(node, ancestry, function (length) {
                    return selector.index.value - 1;
                });

        case &#x27;nth-last-child&#x27;:
            return matches(node, selector.right, ancestry) &#x26;&#x26;
                nthChild(node, ancestry, function (length) {
                    return length - selector.index.value;
                });

        case &#x27;class&#x27;:
            if(!node.type) return false;
            switch(selector.name.toLowerCase()){
                case &#x27;statement&#x27;:
                    if(node.type.slice(-9) === &#x27;Statement&#x27;) return true; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esquery.parse" id="apidoc.element.react-monocle.esquery.parse">
        function <span class="apidocSignatureSpan">react-monocle.esquery.</span>parse
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(selector) {
    return parser.parse(selector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return results;
}

/**
 * Parse a selector string and return its AST.
 */
function parse(selector) {
    return parser.<span class="apidocCodeKeywordSpan">parse</span>(selector);
}

/**
 * Query the code AST using the selector string.
 */
function query(ast, selector) {
    return match(ast, parse(selector));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esquery.query" id="apidoc.element.react-monocle.esquery.query">
        function <span class="apidocSignatureSpan">react-monocle.esquery.</span>query
        <span class="apidocSignatureSpan">(ast, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(ast, selector) {
    return match(ast, parse(selector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.esrecurse" id="apidoc.module.react-monocle.esrecurse">module react-monocle.esrecurse</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.esrecurse.Visitor" id="apidoc.element.react-monocle.esrecurse.Visitor">
        function <span class="apidocSignatureSpan">react-monocle.esrecurse.</span>Visitor
        <span class="apidocSignatureSpan">(visitor, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Visitor(visitor, options) {
    options = options || {};

    this.__visitor = visitor ||  this;
    this.__childVisitorKeys = options.childVisitorKeys
        ? assign({}, estraverse.VisitorKeys, options.childVisitorKeys)
        : estraverse.VisitorKeys;
    if (options.fallback === &#x27;iteration&#x27;) {
        this.__fallback = objectKeys;
    } else if (typeof options.fallback === &#x27;function&#x27;) {
        this.__fallback = options.fallback;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esrecurse.visit" id="apidoc.element.react-monocle.esrecurse.visit">
        function <span class="apidocSignatureSpan">react-monocle.esrecurse.</span>visit
        <span class="apidocSignatureSpan">(node, visitor, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visit = function (node, visitor, options) {
    var v = new Visitor(visitor, options);
    v.visit(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        for (i = 0, iz = children.length; i &#x3c; iz; ++i) {
child = node[children[i]];
if (child) {
    if (isArray(child)) {
        for (j = 0, jz = child.length; j &#x3c; jz; ++j) {
            if (child[j]) {
                if (isNode(child[j]) || isProperty(type, children[i])) {
                    this.<span class="apidocCodeKeywordSpan">visit</span>(child[j]);
                }
            }
        }
    } else if (isNode(child)) {
        this.visit(child);
    }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.estraverse" id="apidoc.module.react-monocle.estraverse">module react-monocle.estraverse</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.Controller" id="apidoc.element.react-monocle.estraverse.Controller">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>Controller
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Controller() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.attachComments" id="apidoc.element.react-monocle.estraverse.attachComments">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>attachComments
        <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachComments(tree, providedComments, tokens) {
      // At first, we should calculate extended comment ranges.
  var comments = [], comment, len, i, cursor;

  if (!tree.range) {
    throw new Error(&#x27;attachComments needs range information&#x27;);
  }

      // tokens array is empty, we attach comments to tree as &#x27;leadingComments&#x27;
  if (!tokens.length) {
    if (providedComments.length) {
      for (i = 0, len = providedComments.length; i &#x3c; len; i += 1) {
          comment = deepCopy(providedComments[i]);
          comment.extendedRange = [0, tree.range[0]];
          comments.push(comment);
        }
      tree.leadingComments = comments;
    }
    return tree;
  }

  for (i = 0, len = providedComments.length; i &#x3c; len; i += 1) {
    comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
  }

      // This is based on John Freeman&#x27;s implementation.
  cursor = 0;
  traverse(tree, {
    enter(node) {
      var comment;

      while (cursor &#x3c; comments.length) {
          comment = comments[cursor];
          if (comment.extendedRange[1] &#x3e; node.range[0]) {
              break;
            }

          if (comment.extendedRange[1] === node.range[0]) {
              if (!node.leadingComments) {
                  node.leadingComments = [];
                }
              node.leadingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
        }

              // already out of owned node
      if (cursor === comments.length) {
          return VisitorOption.Break;
        }

      if (comments[cursor].extendedRange[0] &#x3e; node.range[1]) {
          return VisitorOption.Skip;
        }
    },
  });

  cursor = 0;
  traverse(tree, {
    leave(node) {
      var comment;

      while (cursor &#x3c; comments.length) {
          comment = comments[cursor];
          if (node.range[1] &#x3c; comment.extendedRange[0]) {
              break;
            }

          if (node.range[1] === comment.extendedRange[0]) {
              if (!node.trailingComments) {
                  node.trailingComments = [];
                }
              node.trailingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
        }

              // already out of owned node
      if (cursor === comments.length) {
          return VisitorOption.Break;
        }

      if (comments[cursor].extendedRange[0] &#x3e; node.range[1]) {
          return VisitorOption.Skip;
        }
    },
  });

  return tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.cloneEnvironment" id="apidoc.element.react-monocle.estraverse.cloneEnvironment">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>cloneEnvironment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneEnvironment = function () { return clone({}); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.replace" id="apidoc.element.react-monocle.estraverse.replace">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>replace
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(root, visitor) {
  var controller = new Controller();
  return controller.replace(root, visitor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Any character may appear in the form of an escape sequence.
*
* For portability, we also escape escape all control and non-ASCII
* characters. Note that &#x22;\0&#x22; and &#x22;\v&#x22; escape sequences are not used
* because JSHint does not like the first and IE the second.
*/
return &#x27;&#x22;&#x27; + s
 .<span class="apidocCodeKeywordSpan">replace</span>(/\\/g, &#x27;\\\\&#x27;)  // backslash
 .replace(/&#x22;/g, &#x27;\\&#x22;&#x27;)    // closing quote character
 .replace(/\x08/g, &#x27;\\b&#x27;) // backspace
 .replace(/\t/g, &#x27;\\t&#x27;)   // horizontal tab
 .replace(/\n/g, &#x27;\\n&#x27;)   // line feed
 .replace(/\f/g, &#x27;\\f&#x27;)   // form feed
 .replace(/\r/g, &#x27;\\r&#x27;)   // carriage return
 .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.traverse" id="apidoc.element.react-monocle.estraverse.traverse">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>traverse
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(root, visitor) {
  var controller = new Controller();
  return controller.traverse(root, visitor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * From a JS AST and a selector AST, collect all JS AST nodes that match the selector.
 */
function match(ast, selector) {
    var ancestry = [], results = [], altSubjects, i, l, k, m;
    if (!selector) { return results; }
    altSubjects = subjects(selector);
    estraverse.<span class="apidocCodeKeywordSpan">traverse</span>(ast, {
        enter: function (node, parent) {
            if (parent != null) { ancestry.unshift(parent); }
            if (matches(node, selector, ancestry)) {
                if (altSubjects.length) {
                    for (i = 0, l = altSubjects.length; i &#x3c; l; ++i) {
                        if (matches(node, altSubjects[i], ancestry)) { results.push(node); }
                        for (k = 0, m = ancestry.length; k &#x3c; m; ++k) {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.parser" id="apidoc.module.react-monocle.parser">module react-monocle.parser</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.parser.SyntaxError" id="apidoc.element.react-monocle.parser.SyntaxError">
        function <span class="apidocSignatureSpan">react-monocle.parser.</span>SyntaxError
        <span class="apidocSignatureSpan">(expected, found, offset, line, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SyntaxError = function (expected, found, offset, line, column) {
  function buildMessage(expected, found) {
    var expectedHumanized, foundHumanized;

    switch (expected.length) {
      case 0:
        expectedHumanized = &#x22;end of input&#x22;;
        break;
      case 1:
        expectedHumanized = expected[0];
        break;
      default:
        expectedHumanized = expected.slice(0, expected.length - 1).join(&#x22;, &#x22;)
          + &#x22; or &#x22;
          + expected[expected.length - 1];
    }

    foundHumanized = found ? quote(found) : &#x22;end of input&#x22;;

    return &#x22;Expected &#x22; + expectedHumanized + &#x22; but &#x22; + foundHumanized + &#x22; found.&#x22;;
  }

  this.name = &#x22;SyntaxError&#x22;;
  this.expected = expected;
  this.found = found;
  this.message = buildMessage(expected, found);
  this.offset = offset;
  this.line = line;
  this.column = column;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * handle these states.
 */
if (result === null || pos !== input.length) {
  var offset = Math.max(pos, rightmostFailuresPos);
  var found = offset &#x3c; input.length ? input.charAt(offset) : null;
  var errorPosition = computeErrorPosition();

  throw new this.<span class="apidocCodeKeywordSpan">SyntaxError</span>(
    cleanupExpected(rightmostFailuresExpected),
    found,
    offset,
    errorPosition.line,
    errorPosition.column
  );
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.parser.parse" id="apidoc.element.react-monocle.parser.parse">
        function <span class="apidocSignatureSpan">react-monocle.parser.</span>parse
        <span class="apidocSignatureSpan">(input, startRule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (input, startRule) {
  var parseFunctions = {
    &#x22;start&#x22;: parse_start,
    &#x22;_&#x22;: parse__,
    &#x22;identifierName&#x22;: parse_identifierName,
    &#x22;binaryOp&#x22;: parse_binaryOp,
    &#x22;selectors&#x22;: parse_selectors,
    &#x22;selector&#x22;: parse_selector,
    &#x22;sequence&#x22;: parse_sequence,
    &#x22;atom&#x22;: parse_atom,
    &#x22;wildcard&#x22;: parse_wildcard,
    &#x22;identifier&#x22;: parse_identifier,
    &#x22;attr&#x22;: parse_attr,
    &#x22;attrOps&#x22;: parse_attrOps,
    &#x22;attrEqOps&#x22;: parse_attrEqOps,
    &#x22;attrName&#x22;: parse_attrName,
    &#x22;attrValue&#x22;: parse_attrValue,
    &#x22;string&#x22;: parse_string,
    &#x22;number&#x22;: parse_number,
    &#x22;path&#x22;: parse_path,
    &#x22;type&#x22;: parse_type,
    &#x22;regex&#x22;: parse_regex,
    &#x22;field&#x22;: parse_field,
    &#x22;negation&#x22;: parse_negation,
    &#x22;matches&#x22;: parse_matches,
    &#x22;firstChild&#x22;: parse_firstChild,
    &#x22;lastChild&#x22;: parse_lastChild,
    &#x22;nthChild&#x22;: parse_nthChild,
    &#x22;nthLastChild&#x22;: parse_nthLastChild,
    &#x22;class&#x22;: parse_class
  };

  if (startRule !== undefined) {
    if (parseFunctions[startRule] === undefined) {
      throw new Error(&#x22;Invalid rule name: &#x22; + quote(startRule) + &#x22;.&#x22;);
    }
  } else {
    startRule = &#x22;start&#x22;;
  }

  var pos = 0;
  var reportFailures = 0;
  var rightmostFailuresPos = 0;
  var rightmostFailuresExpected = [];
  var cache = {};

  function padLeft(input, padding, length) {
    var result = input;

    var padLength = length - input.length;
    for (var i = 0; i &#x3c; padLength; i++) {
      result = padding + result;
    }

    return result;
  }

  function escape(ch) {
    var charCode = ch.charCodeAt(0);
    var escapeChar;
    var length;

    if (charCode &#x3c;= 0xFF) {
      escapeChar = &#x27;x&#x27;;
      length = 2;
    } else {
      escapeChar = &#x27;u&#x27;;
      length = 4;
    }

    return &#x27;\\&#x27; + escapeChar + padLeft(charCode.toString(16).toUpperCase(), &#x27;0&#x27;, length);
  }

  function matchFailed(failure) {
    if (pos &#x3c; rightmostFailuresPos) {
      return;
    }

    if (pos &#x3e; rightmostFailuresPos) {
      rightmostFailuresPos = pos;
      rightmostFailuresExpected = [];
    }

    rightmostFailuresExpected.push(failure);
  }

  function parse_start() {
    var cacheKey = &#x22;start@&#x22; + pos;
    var cachedResult = cache[cacheKey];
    if (cachedResult) {
      pos = cachedResult.nextPos;
      return cachedResult.result;
    }

    var result0, result1, result2;
    var pos0, pos1;

    pos0 = pos;
    pos1 = pos;
    result0 = parse__();
    if (result0 !== null) {
      result1 = parse_selectors();
      if (result1 !== null) {
        result2 = parse__();
        if (result2 !== null) {
          result0 = [result0, result1, result2];
        } else {
          result0 = null;
          pos = pos1;
        }
      } else {
        result0 = null;
        pos = pos1;
      }
    } else {
      result0 = null;
      pos = pos1;
    }
    if (result0 !== null) {
      result0 = (function(offset, ss) { return ss.length === 1 ? ss[0] : { type: &#x27;matches&#x27;, selectors: ss }; })(pos0, result0[1]);
    }
    if (result0 === null) {
      pos = pos0;
    }
    if (result0 === null) {
      pos0 = pos;
      result0 = parse__();
      if (result0 !== null) {
        result0 = (function(offset) { return void 0; })(pos0);
      }
      if (result0 === null) {
        pos = pos0;
      }
    }

    cache[cacheKey] = {
      nextPos: pos,
      result:  result0
    };
    return result0;
  }

  function parse__() {
    var cacheKey = &#x22;_@&#x22; + pos;
    var cachedResult = cache[cacheKey];
    if (cachedResult) {
      pos = cachedResult.nextPos;
      return cachedResult.result;
    }

    var result0, result1;

    result0 = [];
    if (input.charCodeAt(pos) === 32) {
      result1 = &#x22; &#x22;;
      pos++;
    } else {
      result1 = null;
      if (reportFailures === 0) {
        matchFailed(&#x22;\&#x22; \&#x22;&#x22;);
      }
    }
    while (result1 !== null) {
      result0.push(result1);
      if (input.charCodeAt(pos) === 32) {
        result1 = &#x22; &#x22;;
        pos++;
      } else {
        result1 = null;
        if (reportFailures === 0) {
          matchFailed(&#x22;\&#x22; \&#x22;&#x22;);
        }
      }
    }

    cache[cacheKey ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return results;
}

/**
 * Parse a selector string and return its AST.
 */
function parse(selector) {
    return parser.<span class="apidocCodeKeywordSpan">parse</span>(selector);
}

/**
 * Query the code AST using the selector string.
 */
function query(ast, selector) {
    return match(ast, parse(selector));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.parser.toSource" id="apidoc.element.react-monocle.parser.toSource">
        function <span class="apidocSignatureSpan">react-monocle.parser.</span>toSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSource = function () { return this._source; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.previewParser" id="apidoc.module.react-monocle.previewParser">module react-monocle.previewParser</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.getComponentName" id="apidoc.element.react-monocle.previewParser.getComponentName">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>getComponentName
        <span class="apidocSignatureSpan">(bundle, startingIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getComponentName(bundle, startingIndex) {
  let bundleSearchIndicesMap = {};
  // get index of component declaration
  bundleSearchIndicesMap[regexLastIndexOf(bundle, /(var )?\w+\s*?=\s*(\(\d+\, )?_react(\d+\[\&#x22;\w+\&#x22;\])?.createClass/, startingIndex
)] = &#x27;WEBPACKES5&#x27;;
  // let&#x27;s try ES6...
  bundleSearchIndicesMap[regexLastIndexOf(bundle, /(var )?\w+\s*?=\s*?function\s*?\(_(React\$)?Component\)/, startingIndex)] = &#x27;
WEBPACKES6&#x27;;
  // let&#x27;s try GULP
  bundleSearchIndicesMap[regexLastIndexOf(bundle, /var \w+ = React.createClass\({/, startingIndex)] = &#x27;GULP&#x27;;
  // let&#x27;s try Rollup ex: var Slick = (function (superclass) {
  bundleSearchIndicesMap[regexLastIndexOf(bundle, /var \w+ = \(function \(superclass\) {/, startingIndex)] = &#x27;ROLLUP&#x27;;
  const targetIndex = Object.keys(bundleSearchIndicesMap)
  	.filter(index =&#x3e; index &#x3e;= 0)
  	.reduce((prev, curr) =&#x3e; {
  	  return Math.abs(curr-startingIndex) &#x3c; Math.abs(prev-startingIndex)
  	  	? curr
  	  	: prev;
  	});

  let componentMatch;
  switch(bundleSearchIndicesMap[targetIndex]) {
  	case &#x27;WEBPACKES5&#x27;:
  	  componentMatch = bundle.slice(targetIndex)
  	  	.match(/(var )?\w+\s*?=\s*(\(\d+\, )?_react(\d+\[\&#x22;\w+\&#x22;\])?.createClass/)
  	  break;
    case &#x27;WEBPACKES6&#x27;:
   	  componentMatch = bundle.slice(targetIndex)
  	    .match(/(var )?\w+\s*?=\s*?function\s*?\(_(React\$)?Component\)/)
   	  break;
    case &#x27;GULP&#x27;:
      componentMatch = bundle.slice(targetIndex)
        .match(/var \w+ = React.createClass\({/)
      break;
    case &#x27;ROLLUP&#x27;:
      componentMatch = bundle.slice(targetIndex)
        .match(/var \w+ = \(function \(superclass\) {/)
      break;
    default:
    	throw new Error(&#x27;Unable to find component from bundle file&#x27;);
  }

  // need to normalize component name (remove declarator ex. var, const)
  return componentMatch[0]
    .replace(/var |const /, &#x27;&#x27;)
    .replace(/ /g, &#x27;&#x27;)
    .split(&#x27;=&#x27;)[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.getDivs" id="apidoc.element.react-monocle.previewParser.getDivs">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>getDivs
        <span class="apidocSignatureSpan">(modifiedBundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDivs(modifiedBundle) {
  let index = modifiedBundle.indexOf(&#x27;getElementById(&#x27;, 0);
  let divsArr = [];
  while (index !== -1) {
    let openParenIdx = modifiedBundle.indexOf(&#x27;(&#x27;, index - 1);
    let currentIdx = openParenIdx + 1;
    const parensStack = [&#x27;(&#x27;];
    while (parensStack.length !== 0) {
      if (modifiedBundle[currentIdx] === &#x27;(&#x27;) parensStack.push(modifiedBundle[currentIdx]);
      if (modifiedBundle[currentIdx] === &#x27;)&#x27;) parensStack.pop();
      currentIdx++;
    }
    divsArr.push(modifiedBundle.slice(openParenIdx + 2, currentIdx - 2));
    index = modifiedBundle.indexOf(&#x27;getElementById(&#x27;, index + 1);
  }
  divsArr = divsArr.map(ele =&#x3e; {
    return `&#x3c;div id=&#x27;${ele}&#x27;&#x3e;&#x3c;/div&#x3e;`;
  });
  const uniqueArr = [];
  for (let i = 0; i &#x3c; divsArr.length; i++) {
    if (uniqueArr.indexOf(divsArr[i]) &#x3c; 0) {
      uniqueArr.push(divsArr[i]);
    }
  }
  return uniqueArr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.modifyBundleFile" id="apidoc.element.react-monocle.previewParser.modifyBundleFile">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyBundleFile
        <span class="apidocSignatureSpan">(bundlejs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modifyBundleFile(bundlejs) {
  const bundle = fs.readFileSync(bundlejs, { encoding: &#x27;utf-8&#x27; });
  if (bundle.length === 0) throw new Error(&#x27;Empty AST input&#x27;);
  const searchState = /this.setState/g;
  const wrappedFunc = &#x27;wrapper(this.setState)&#x27;;
  const searchElem = /(getElementById\([\&#x27;\&#x22;])\w+[\&#x27;\&#x22;]/;
  const newMount = &#x27;getElementById(&#x22;preview&#x22;&#x27;;
  const replacedState = bundle.replace(searchState, wrappedFunc);
  return replacedState.replace(searchElem, newMount);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.modifyInitialState" id="apidoc.element.react-monocle.previewParser.modifyInitialState">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyInitialState
        <span class="apidocSignatureSpan">(modifiedBundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modifyInitialState(modifiedBundle) {
  let index = -1;
  if (modifiedBundle.indexOf(&#x27;_this.state&#x27;) &#x3e;= 0) {
    // do webpack
    index = modifiedBundle.indexOf(&#x27;_this.state&#x27;, 0);
  } else if (modifiedBundle.indexOf(&#x27;getInitialState() {&#x27;, 0) &#x3e;= 0) {
    // do gulp
    index = modifiedBundle.indexOf(&#x27;getInitialState() {&#x27;, 0) + 19;
  } else if (modifiedBundle.indexOf(&#x27;this.state&#x27;, 0) &#x3e;= 0) {
    // do rollup
    index = modifiedBundle.indexOf(&#x27;this.state = {&#x27;);
  } else {
    throw new Error(&#x27;Unable to find component initial state&#x27;);
  }

  while (index !== -1) {
    let openBraceIdx = modifiedBundle.indexOf(&#x27;{&#x27;, index); // looking for index of follow brace, after return statement
    let currentIdx = openBraceIdx + 1;
    const parensStack = [&#x27;{&#x27;];
    while (parensStack.length !== 0) {
      if (modifiedBundle[currentIdx] === &#x27;{&#x27;) parensStack.push(modifiedBundle[currentIdx]);
      if (modifiedBundle[currentIdx] === &#x27;}&#x27;) parensStack.pop();
      currentIdx++;
    }

    let injection,
        componentName = getComponentName(modifiedBundle, index),
        stateStr = modifiedBundle.slice(openBraceIdx, currentIdx);
    if (modifiedBundle.indexOf(&#x27;_this.state&#x27;, 0) &#x3e;= 0) {
      injection = `_this.state = grabInitialState(&#x27;${componentName}&#x27;, ${stateStr}),`;
    } else if (modifiedBundle.indexOf(&#x27;getInitialState() {&#x27;, 0) &#x3e;= 0) {
      injection = `return grabInitialState(&#x27;${componentName}&#x27;, ${stateStr}),`;
    } else if (modifiedBundle.indexOf(&#x27;this.state = {&#x27;, 0) &#x3e;= 0) {
      injection = `this.state = grabInitialState(&#x27;${componentName}&#x27;, ${stateStr}),`;
    }

    modifiedBundle = modifiedBundle.slice(0, index) + injection + modifiedBundle.slice(currentIdx + 1);

    // need to take into account that length of bundle now changes since injected wrapper string length can be different than original
    const oldLength = currentIdx - index;
    const newLength = injection.length;

    if (modifiedBundle.indexOf(&#x27;_this.state&#x27;) &#x3e;= 0) {
      index = modifiedBundle.indexOf(&#x27;_this.state&#x27;, index + 1 + newLength - oldLength);
    } else if (modifiedBundle.indexOf(&#x27;getInitialState() {&#x27;) &#x3e;= 0) {
      index = modifiedBundle.indexOf(&#x27;getInitialState() {&#x27;, index + 1 + newLength - oldLength);
    } else if (modifiedBundle.indexOf(&#x27;this.state = grabInitialState&#x27;) &#x3e;= 0) {
      index = modifiedBundle.indexOf(&#x27;this.state = grabInitialState&#x27;, index + 1 + newLength - oldLength);
    } else {
      throw new Error(&#x27;Unable to find next initial state index&#x27;);
    }
  }
  return modifiedBundle;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.modifySetStateStrings" id="apidoc.element.react-monocle.previewParser.modifySetStateStrings">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifySetStateStrings
        <span class="apidocSignatureSpan">(bundleFilePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modifySetStateStrings(bundleFilePath) {
  let bundle;
  try {
    bundle = fs.readFileSync(bundleFilePath, { encoding: &#x27;utf-8&#x27; });
  } catch(error) {
    throw new Error(&#x27;Invalid bundle file path specified. Please enter a valid path to your app\&#x27;s bundle file&#x27;);
  }

  if (bundle.length == 0) throw new Error(&#x27;Bundle string is empty, provide valid bundle string input&#x27;);

  console.log(&#x27;Starting to strip comments from bundle file...&#x27;);
  const start = Date.now();
  let modifiedBundle = strip(bundle.slice());
  console.log(`Took ${(Date.now() - start) / 1000} seconds to strip comments input bundle file`);
  let index = modifiedBundle.indexOf(&#x27;this.setState&#x27;, 0);
  while (index !== -1) {
    let openBraceIdx = modifiedBundle.indexOf(&#x27;{&#x27;, index);
    let currentIdx = openBraceIdx + 1;
    const parensStack = [&#x27;{&#x27;];
    while (parensStack.length !== 0) {
      if (modifiedBundle[currentIdx] === &#x27;{&#x27;) parensStack.push(modifiedBundle[currentIdx]);
      if (modifiedBundle[currentIdx] === &#x27;}&#x27;) parensStack.pop();
      currentIdx++;
    }
    const stateStr = modifiedBundle.slice(openBraceIdx, currentIdx);
    const functionStartIdx = currentIdx;
    parensStack.push(&#x27;(&#x27;);
    while (parensStack.length !== 0) {
      if (modifiedBundle[currentIdx] === &#x27;(&#x27;) parensStack.push(modifiedBundle[currentIdx]);
      if (modifiedBundle[currentIdx] === &#x27;)&#x27;) parensStack.pop();
      currentIdx++;
    }
    currentIdx--;
    const callbackStr = modifiedBundle.slice(functionStartIdx, currentIdx);
    const injection = `wrapper(&#x27;${getComponentName(modifiedBundle, index)}&#x27;,this)(${ stateStr }${ callbackStr })`;
    modifiedBundle = modifiedBundle.slice(0, index) + injection + modifiedBundle.slice(currentIdx + 1);
    // need to take into account that length of bundle now changes since injected wrapper string length can be different than original
    const oldLength = currentIdx - index;
    const newLength = injection.length;

    index = modifiedBundle.indexOf(&#x27;this.setState&#x27;, index+1+newLength-oldLength);
  }
  return modifiedBundle;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.modifyTestBundleFile" id="apidoc.element.react-monocle.previewParser.modifyTestBundleFile">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyTestBundleFile
        <span class="apidocSignatureSpan">(bundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modifyTestBundleFile(bundle) {
  if (bundle.length === 0) throw new Error(&#x27;Empty AST input&#x27;);
  const searchState = /this.setState/g;
  const wrappedFunc = &#x27;wrapper(this.setState)&#x27;;
  const searchElem = /(getElementById\([\&#x27;\&#x22;])\w+[\&#x27;\&#x22;]/;
  const newMount = &#x27;getElementById(&#x22;preview&#x22;&#x27;;
  const replacedState = bundle.replace(searchState, wrappedFunc);
  return replacedState.replace(searchElem, newMount);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.queryES5Ast" id="apidoc.element.react-monocle.previewParser.queryES5Ast">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>queryES5Ast
        <span class="apidocSignatureSpan">(bundlejs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queryES5Ast(bundlejs) {
  if (!bundlejs) throw new Error(&#x27;Empty bundle file input&#x27;);
  const bundle = fs.readFileSync(bundlejs, { encoding: &#x27;utf-8&#x27; });
  const ast = acorn.parse(bundle);
  if (ast.body.length === 0) throw new Error(&#x27;Empty AST input&#x27;);
  const parseInfo = esquery.parse(&#x27;[id.name=&#x22;getInitialState&#x22;]&#x27;);
  const match = esquery.match(ast, parseInfo);
  const finalStateArr = [];
  if (match.length === 0) return {};
  match.map(ele =&#x3e; {
    const valueObj = {};
    ele.body.body.map(index =&#x3e; {
      if (index.type === &#x27;ReturnStatement&#x27;) {
        index.argument.properties.map(node =&#x3e; {
          if (node.value.hasOwnProperty(&#x27;value&#x27;)) {
            valueObj[node.key.name] = node.value.value;
          } else if (node.value.hasOwnProperty(&#x27;name&#x27;)) {
            valueObj[node.key.name] = node.value.name;
          } else if (node.value.hasOwnProperty(&#x27;elements&#x27;)) {
            valueObj[node.key.name] = node.value.elements;
          }
        });
        finalStateArr.push(valueObj);
      }
    });
  });
  return structureInitialES5StateObj(bundlejs, finalStateArr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.queryES6Ast" id="apidoc.element.react-monocle.previewParser.queryES6Ast">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>queryES6Ast
        <span class="apidocSignatureSpan">(bundlejs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queryES6Ast(bundlejs) {
  if (!bundlejs) throw new Error(&#x27;Empty bundle file input&#x27;);
  const bundle = fs.readFileSync(bundlejs, { encoding: &#x27;utf-8&#x27; });
  const ast = acorn.parse(bundle);
  if (ast.body.length === 0) throw new Error(&#x27;Empty AST input&#x27;);
  const parseInfo = esquery.parse(&#x27;ExpressionStatement&#x27;);
  const match = esquery.match(ast, parseInfo);
  const finalStateArr = [];
  if (match.length === 0) return {};
  match.map(ele =&#x3e; {
    const valueObj = {};
    if (ele.expression.left) {
      if (ele.expression.left.object) {
        if (ele.expression.left.object.name === &#x27;_this&#x27;) {
          const valueNode = ele.expression.right.properties;
          valueNode.map(node =&#x3e; {
            const finalValArr = [];
            if (node.value.elements) {
              node.value.elements.map(index =&#x3e; {
                finalValArr.push(index.value);
              });
            }
            valueObj[node.key.name] = node.value.value || finalValArr;
          });
          finalStateArr.push(valueObj);
        }
      }
    }
  });
  return structureInitialES6StateObj(bundle, finalStateArr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.structureInitialES5StateObj" id="apidoc.element.react-monocle.previewParser.structureInitialES5StateObj">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>structureInitialES5StateObj
        <span class="apidocSignatureSpan">(bundle, arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function structureInitialES5StateObj(bundle, arr) {
  if (arr.length === 0) return {};
  let initialStateIndex = bundle.indexOf(&#x27;getInitialState()&#x27;, 0);
  const objForReduxStore = {};
  for (let i = 0; i &#x3c; arr.length; i++) {
    const arrOfStateObjs = [];
    for (const key in arr[i]) {
      arrOfStateObjs.push({
        name: key,
        value: arr[i][key],
      });
      objForReduxStore[getComponentName(bundle, initialStateIndex)] = arrOfStateObjs;
    }
    initialStateIndex = bundle.indexOf(&#x27;getInitialState()&#x27;, initialStateIndex + 1);
  }
  return objForReduxStore;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.structureInitialES6StateObj" id="apidoc.element.react-monocle.previewParser.structureInitialES6StateObj">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>structureInitialES6StateObj
        <span class="apidocSignatureSpan">(bundle, arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function structureInitialES6StateObj(bundle, arr) {
  if (arr.length === 0) return {};
  let initialStateIndex = bundle.indexOf(&#x27;_this.state&#x27;, 0);
  const objForReduxStore = {};
  for (let i = 0; i &#x3c; arr.length; i++) {
    const arrOfStateObjs = [];
    for (const key in arr[i]) {
      arrOfStateObjs.push({
        name: key,
        value: arr[i][key],
      });
      objForReduxStore[getComponentName(bundle, initialStateIndex)] = arrOfStateObjs;
    }
    initialStateIndex = bundle.indexOf(&#x27;_this.state&#x27;, initialStateIndex + 1);
  }
  return objForReduxStore;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.reactParser" id="apidoc.module.react-monocle.reactParser">module react-monocle.reactParser</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.componentChecker" id="apidoc.element.react-monocle.reactParser.componentChecker">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>componentChecker
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function componentChecker(ast) {
  for (let i = 0; i &#x3c; ast.body.length; i++) {
    if (ast.body[i].type === &#x27;ClassDeclaration&#x27;) return &#x27;ES6&#x27;;
    if (ast.body[i].type === &#x27;ExportDefaultDeclaration&#x27; &#x26;&#x26; ast.body[i].declaration.type === &#x27;ClassDeclaration&#x27;) return &#x27;ES6&#x27;;
    if (ast.body[i].type === &#x27;VariableDeclaration&#x27; &#x26;&#x26; ast.body[i].declarations[0].init
     &#x26;&#x26; ast.body[i].declarations[0].init.callee
    &#x26;&#x26; ast.body[i].declarations[0].init.callee.object &#x26;&#x26; ast.body[i].declarations[0].init.callee.object.name === &#x27;React&#x27;
    &#x26;&#x26; ast.body[i].declarations[0].init.callee.property.name === &#x27;createClass&#x27;) return &#x27;ES5&#x27;
  }
  return &#x27;SFC&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function d3DataBuilder(obj) {
if (!obj.ENTRY) throw new Error(&#x27;Entry component not found&#x27;);
const formatted = {};

// parsing AST into formatted objects based on ES5/ES6 syntax
for (const key in obj) {
  if (key === &#x27;ENTRY&#x27;) continue;
  const componentChecker = reactParser.<span class="apidocCodeKeywordSpan">componentChecker</span>(obj[key]);
  // componentChecker returns true for es6 classes, false for everything else
  if (componentChecker === &#x27;ES6&#x27;) formatted[key] = reactParser.getES6ReactComponents(obj[key]);
  else if (componentChecker === &#x27;ES5&#x27;) formatted[key] = reactParser.getES5ReactComponents(obj[key]);
  else formatted[key] = reactParser.getStatelessFunctionalComponents(obj[key], key)
}

for (const key in formatted) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.forInFinder" id="apidoc.element.react-monocle.reactParser.forInFinder">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>forInFinder
        <span class="apidocSignatureSpan">(arr, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forInFinder(arr, name) {
  const result = arr.map(ele =&#x3e; {
    const jsxnode = esquery(ele, &#x27;JSXElement&#x27;)[0];
    const obj = {};
    obj.variables = {};
    esquery(ele, &#x27;VariableDeclarator&#x27;).forEach(vars =&#x3e; {
      if (vars.id.name !== &#x27;i&#x27; &#x26;&#x26; vars.init) {
        obj.variables[vars.id.name] = escodegen.generate(vars.init).replace(&#x27;this.&#x27;, &#x27;&#x27;);
      }
    });
    if (ele.left.declarations) obj.variables[ele.left.declarations[0].id.name] = &#x27;[key]&#x27;;
    else if (ele.left.type === &#x27;Identifier&#x27;) obj.variables[ele.left.name] = &#x27;[key]&#x27;;

    if (jsxnode &#x26;&#x26; htmlElements.indexOf(jsxnode.openingElement.name.name)) {
      let current = ele.right;
      let found;
      while (current &#x26;&#x26; current.property) {
        found = `.${current.property.name}${found || &#x27;&#x27;}`;
        current = current.object;
        if (current.type === &#x27;Identifier&#x27;) {
          found = `.${current.name}${found || &#x27;&#x27;}`;
          break;
        }
      }

      obj.jsx = {
        name: jsxnode.openingElement.name.name,
        children: getChildJSXElements(jsxnode, name),
        props: getReactProps(jsxnode, name),
        state: {},
        methods: [],
        iterated: &#x27;forIn&#x27;,
        source: found.replace(&#x27;.&#x27;, &#x27;&#x27;),
      };
      const propsArr = obj.jsx.props;
      for (let i = 0; i &#x3c; propsArr.length; i++) {
        for (const key in obj.variables) {
          if (propsArr[i].value.includes(key)) {
            if (obj.variables[key] === &#x27;[key]&#x27;) propsArr[i].value = propsArr[i].value.replace(`.${key}`, obj.variables[key]);
            else propsArr[i].value = propsArr[i].value.replace(key, obj.variables[key]);
          }
        }
      }
    }
    return obj;
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.forLoopFinder" id="apidoc.element.react-monocle.reactParser.forLoopFinder">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>forLoopFinder
        <span class="apidocSignatureSpan">(arr, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forLoopFinder(arr, name) {
  const result = arr.map(ele =&#x3e; {
    const jsxnode = esquery(ele, &#x27;JSXElement&#x27;)[0];
    const obj = {};
    obj.variables = {};

    // finding variables in case information was reassigned
    esquery(ele, &#x27;VariableDeclarator&#x27;).forEach(vars =&#x3e; {
      if (vars.id.name !== &#x27;i&#x27; &#x26;&#x26; vars.init) {
        obj.variables[vars.id.name] = escodegen.generate(vars.init).replace(&#x27;this.&#x27;, &#x27;&#x27;).replace(&#x27;.length&#x27;, &#x27;&#x27;);
      }
    });

    // defaulting each iteration to be represented by &#x27;i&#x27;
    if (ele.init.declarations) obj.variables[ele.init.declarations[0].id.name] = &#x27;[i]&#x27;;
    else if (ele.init.type === &#x27;AssignmentExpression&#x27;) obj.variables[ele.init.left.name] = &#x27;[i]&#x27;;

    // building the object name
    if (jsxnode &#x26;&#x26; htmlElements.indexOf(jsxnode.openingElement.name.name)) {
      let current = ele.test.right;
      let found;
      while (current &#x26;&#x26; current.property) {
        found = `.${current.property.name}${found || &#x27;&#x27;}`;
        current = current.object;
        if (current.type === &#x27;Identifier&#x27;) {
          found = `.${current.name}${found || &#x27;&#x27;}`;
          break;
        }
      }

      obj.jsx = {
        name: jsxnode.openingElement.name.name,
        children: getChildJSXElements(jsxnode, name),
        props: getReactProps(jsxnode, name),
        state: {},
        methods: [],
        iterated: &#x27;forLoop&#x27;,
        source: found.replace(&#x27;.&#x27;, &#x27;&#x27;).replace(&#x27;.length&#x27;, &#x27;&#x27;),
      };

      // replacing variables with their properties
      const propsArr = obj.jsx.props;
      for (let i = 0; i &#x3c; propsArr.length; i++) {
        for (const key in obj.variables) {
          if (propsArr[i].value.includes(key)) {
            if (obj.variables[key] === &#x27;[i]&#x27;) propsArr[i].value = propsArr[i].value.replace(`.${key}`, obj.variables[key]);
            else propsArr[i].value = propsArr[i].value.replace(key, obj.variables[key]);
          }
        }
      }
    }
    return obj;
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.getES5ReactComponents" id="apidoc.element.react-monocle.reactParser.getES5ReactComponents">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getES5ReactComponents
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getES5ReactComponents(ast) {
  const output = {
    name: &#x27;&#x27;,
    state: {},
    props: {},
    methods: [],
    children: [],
  };
  let iter = [];
  let topJsxComponent;
  let outside;
  const checker = {};
  esrecurse.visit(ast, {
    VariableDeclarator(node) {
      topJsxComponent = node.id.name;
      this.visitChildren(node);
    },
    MemberExpression(node) {
      if (node.property &#x26;&#x26; node.property.name === &#x27;createClass&#x27;) {
        output.name = topJsxComponent;
      }
      this.visitChildren(node);
    },
    ObjectExpression(node) {
      node.properties.forEach(prop =&#x3e; {
        if (reactMethods.indexOf(prop.key.name) &#x3c; 0
          &#x26;&#x26; prop.value.type === &#x27;FunctionExpression&#x27;) {
          output.methods.push(prop.key.name);
        }
      });
      this.visitChildren(node);
    },
    JSXElement(node) {
      output.children = getChildJSXElements(node, output.name);
      output.props = getReactProps(node, output.name);
      if (htmlElements.indexOf(node.openingElement.name.name) &#x3c; 0) {
        outside = {
          name: node.openingElement.name.name,
          children: getChildJSXElements(node, output.name),
          props: getReactProps(node, output.name),
          state: {},
          methods: [],
        };
      }
    },
  });

  const forIn = esquery(ast, &#x27;ForInStatement&#x27;).filter(ele =&#x3e; {
    const searched = bfs(ele).filter(n =&#x3e; {
      return n.type === &#x27;JSXElement&#x27;;
    });
    return searched.length &#x3e; 0;
  });
  if (forIn.length &#x3e; 0) iter = iter.concat(forInFinder(forIn, output.name));

  const forLoop = esquery(ast, &#x27;ForStatement&#x27;).filter(ele =&#x3e; {
    const searched = bfs(ele).filter(n =&#x3e; {
      return n.type === &#x27;JSXElement&#x27;;
    });
    return searched.length &#x3e; 0;
  });
  if (forLoop.length &#x3e; 0) iter = iter.concat(forLoopFinder(forLoop, output.name));

  const higherOrderFunc = esquery(ast, &#x27;CallExpression&#x27;).filter(ele =&#x3e; {
    let higherOrderChecker = false;
    const searched = bfs(ele).filter(n =&#x3e; {
      return n.type === &#x27;JSXElement&#x27;;
    });
    if (ele.callee.property &#x26;&#x26; ele.callee.property.name.match(/(map|forEach|filter|reduce)/)) {
      higherOrderChecker = ele.callee.property.name.match(/(map|forEach|filter|reduce)/);
    }
    return searched.length &#x3e; 0 &#x26;&#x26; higherOrderChecker;
  });
  if (higherOrderFunc.length &#x3e; 0) iter = iter.concat(higherOrderFunctionFinder(higherOrderFunc, output.name));

  if (outside) output.children.push(outside);
  output.children.forEach((ele, i) =&#x3e; {
    checker[ele.name] = i;
  });

  for (let i = 0; i &#x3c; iter.length; i++) {
    if (checker.hasOwnProperty(iter[i].jsx.name)) {
      output.children[checker[iter[i].jsx.name]] = iter[i].jsx;
    }
  }

  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// parsing AST into formatted objects based on ES5/ES6 syntax
for (const key in obj) {
  if (key === &#x27;ENTRY&#x27;) continue;
  const componentChecker = reactParser.componentChecker(obj[key]);
  // componentChecker returns true for es6 classes, false for everything else
  if (componentChecker === &#x27;ES6&#x27;) formatted[key] = reactParser.getES6ReactComponents(obj[key]);
  else if (componentChecker === &#x27;ES5&#x27;) formatted[key] = reactParser.<span class="apidocCodeKeywordSpan">getES5ReactComponents
</span>(obj[key]);
  else formatted[key] = reactParser.getStatelessFunctionalComponents(obj[key], key)
}

for (const key in formatted) {
  formatted[key].children.forEach(ele =&#x3e; {
    if (Array.isArray(ele.props)) {
      ele.props.forEach((propped, i) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.getES6ReactComponents" id="apidoc.element.react-monocle.reactParser.getES6ReactComponents">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getES6ReactComponents
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getES6ReactComponents(ast) {
  const output = {
    name: &#x27;&#x27;,
    props: {},
    state: {},
    methods: [],
    children: [],
  };
  let iter = [];
  let outside;
  const checker = {};
  esrecurse.visit(ast, {
    ClassDeclaration(node) {
      if (isES6ReactComponent(node)) {
        output.name = node.id.name;
        this.visitChildren(node);
      }
    },
    MethodDefinition(node) {
      if (reactMethods.indexOf(node.key.name) &#x3c; 0) output.methods.push(node.key.name);
      this.visitChildren(node);
    },
    // ExpressionStatement(node) {
    //   if (node.expression.left &#x26;&#x26; node.expression.left.property &#x26;&#x26; node.expression.left.property.name === &#x27;state&#x27;) {
    //     output.state = getReactStates(node.expression.right);
    //   }
    //   this.visitChildren(node);
    // },
    JSXElement(node) {
      // TODO: DO STUFF WITH JSX AFTER FINDING STUFF BOI
      output.children = getChildJSXElements(node, output.name);
      output.props = getReactProps(node, output.name);
      if (htmlElements.indexOf(node.openingElement.name.name) &#x3c; 0) {
        outside = {
          name: node.openingElement.name.name,
          children: getChildJSXElements(node, output.name),
          props: getReactProps(node, output.name),
          state: {},
          methods: [],
        };
      }
      const forIn = esquery(ast, &#x27;ForInStatement&#x27;).filter(ele =&#x3e; {
        const searched = bfs(ele).filter(n =&#x3e; {
          return n.type === &#x27;JSXElement&#x27;;
        });
        return searched.length &#x3e; 0;
      });
      if (forIn.length &#x3e; 0) iter = iter.concat(forInFinder(forIn, output.name));

      const forLoop = esquery(ast, &#x27;ForStatement&#x27;).filter(ele =&#x3e; {
        const searched = bfs(ele).filter(n =&#x3e; {
          return n.type === &#x27;JSXElement&#x27;;
        });
        return searched.length &#x3e; 0;
      });
      if (forLoop.length &#x3e; 0) iter = iter.concat(forLoopFinder(forLoop, output.name));

      const higherOrderFunc = esquery(ast, &#x27;CallExpression&#x27;).filter(ele =&#x3e; {
        let higherOrderChecker = false;
        const searched = bfs(ele).filter(n =&#x3e; {
          return n.type === &#x27;JSXElement&#x27;;
        });
        if (ele.callee.property &#x26;&#x26; ele.callee.property.name.match(/(map|forEach|filter|reduce)/)) {
          higherOrderChecker = ele.callee.property.name.match(/(map|forEach|filter|reduce)/);
        }
        return searched.length &#x3e; 0 &#x26;&#x26; higherOrderChecker;
      });
      if (higherOrderFunc.length &#x3e; 0) iter = iter.concat(higherOrderFunctionFinder(higherOrderFunc, output.name));
    },
  });

  if (outside) output.children.push(outside);
  output.children.forEach((ele, i) =&#x3e; {
    checker[ele.name] = i;
  });

  for (let i = 0; i &#x3c; iter.length; i++) {
    if (checker.hasOwnProperty(iter[i].jsx.name)) {
      output.children[checker[iter[i].jsx.name]] = iter[i].jsx;
    }
  }
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const formatted = {};

// parsing AST into formatted objects based on ES5/ES6 syntax
for (const key in obj) {
  if (key === &#x27;ENTRY&#x27;) continue;
  const componentChecker = reactParser.componentChecker(obj[key]);
  // componentChecker returns true for es6 classes, false for everything else
  if (componentChecker === &#x27;ES6&#x27;) formatted[key] = reactParser.<span class="apidocCodeKeywordSpan">getES6ReactComponents
</span>(obj[key]);
  else if (componentChecker === &#x27;ES5&#x27;) formatted[key] = reactParser.getES5ReactComponents(obj[key]);
  else formatted[key] = reactParser.getStatelessFunctionalComponents(obj[key], key)
}

for (const key in formatted) {
  formatted[key].children.forEach(ele =&#x3e; {
    if (Array.isArray(ele.props)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.getStatelessFunctionalComponents" id="apidoc.element.react-monocle.reactParser.getStatelessFunctionalComponents">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getStatelessFunctionalComponents
        <span class="apidocSignatureSpan">(ast, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStatelessFunctionalComponents(ast, name) {
  const output = {
    name: name,
    state: {},
    props: {},
    methods: [],
    children: [],
  };

  let iter = [];
  let outside;
  const checker = {};
  esrecurse.visit(ast, {
    ObjectExpression(node) {
      node.properties.forEach(prop =&#x3e; {
        if (reactMethods.indexOf(prop.key.name) &#x3c; 0
          &#x26;&#x26; prop.value.type === &#x27;FunctionExpression&#x27;) {
          output.methods.push(prop.key.name);
        }
      });
      this.visitChildren(node);
    },
    JSXElement(node) {
      output.children = getChildJSXElements(node, output.name);
      output.props = getReactProps(node, output.name);
      if (htmlElements.indexOf(node.openingElement.name.name) &#x3c; 0) {
        outside = {
          name: node.openingElement.name.name,
          children: getChildJSXElements(node, output.name),
          props: getReactProps(node, output.name),
          state: {},
          methods: [],
        };
      }
    },
  });

  const forIn = esquery(ast, &#x27;ForInStatement&#x27;).filter(ele =&#x3e; {
    const searched = bfs(ele).filter(n =&#x3e; {
      return n.type === &#x27;JSXElement&#x27;;
    });
    return searched.length &#x3e; 0;
  });
  if (forIn.length &#x3e; 0) iter = iter.concat(forInFinder(forIn, output.name));

  const forLoop = esquery(ast, &#x27;ForStatement&#x27;).filter(ele =&#x3e; {
    const searched = bfs(ele).filter(n =&#x3e; {
      return n.type === &#x27;JSXElement&#x27;;
    });
    return searched.length &#x3e; 0;
  });
  if (forLoop.length &#x3e; 0) iter = iter.concat(forLoopFinder(forLoop, output.name));

  const higherOrderFunc = esquery(ast, &#x27;CallExpression&#x27;).filter(ele =&#x3e; {
    let higherOrderChecker = false;
    const searched = bfs(ele).filter(n =&#x3e; {
      return n.type === &#x27;JSXElement&#x27;;
    });
    if (ele.callee.property &#x26;&#x26; ele.callee.property.name.match(/(map|forEach|filter|reduce)/)) {
      higherOrderChecker = ele.callee.property.name.match(/(map|forEach|filter|reduce)/);
    }
    return searched.length &#x3e; 0 &#x26;&#x26; higherOrderChecker;
  });
  if (higherOrderFunc.length &#x3e; 0) iter = iter.concat(higherOrderFunctionFinder(higherOrderFunc, output.name));

  if (outside) output.children.push(outside);
  output.children.forEach((ele, i) =&#x3e; {
    checker[ele.name] = i;
  });

  for (let i = 0; i &#x3c; iter.length; i++) {
    if (checker.hasOwnProperty(iter[i].jsx.name)) {
      output.children[checker[iter[i].jsx.name]] = iter[i].jsx;
    }
  }
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// parsing AST into formatted objects based on ES5/ES6 syntax
for (const key in obj) {
  if (key === &#x27;ENTRY&#x27;) continue;
  const componentChecker = reactParser.componentChecker(obj[key]);
  // componentChecker returns true for es6 classes, false for everything else
  if (componentChecker === &#x27;ES6&#x27;) formatted[key] = reactParser.getES6ReactComponents(obj[key]);
  else if (componentChecker === &#x27;ES5&#x27;) formatted[key] = reactParser.getES5ReactComponents(obj[key]);
  else formatted[key] = reactParser.<span class="apidocCodeKeywordSpan">getStatelessFunctionalComponents</span>(obj[key], key)
}

for (const key in formatted) {
  formatted[key].children.forEach(ele =&#x3e; {
    if (Array.isArray(ele.props)) {
      ele.props.forEach((propped, i) =&#x3e; {
        if (typeof propped.value === &#x27;object&#x27; &#x26;&#x26; propped.value.name &#x26;&#x26; propped.value.children) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.higherOrderFunctionFinder" id="apidoc.element.react-monocle.reactParser.higherOrderFunctionFinder">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>higherOrderFunctionFinder
        <span class="apidocSignatureSpan">(arr, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function higherOrderFunctionFinder(arr, name) {
  const result = arr.map(ele =&#x3e; {
    // since every higher order function will have some parameter
    // will be used to replace with what it actually is
    const param = ele.arguments[0].params[0].name;
    const jsxnode = esquery(ele, &#x27;JSXElement&#x27;)[0];
    const obj = {};
    obj.variables = {};
    esquery(ele, &#x27;VariableDeclarator&#x27;).forEach(vars =&#x3e; {
      obj.variables[vars.id.name] = escodegen.generate(vars.init);
    });

    if (jsxnode &#x26;&#x26; htmlElements.indexOf(jsxnode.openingElement.name.name)) {
      let current = ele.callee.object;
      let found;
      while (current &#x26;&#x26; current.property) {
        found = `.${current.property.name}${found || &#x27;&#x27;}`;
        current = current.object;
        if (current.type === &#x27;Identifier&#x27;) {
          found = `.${current.name}${found || &#x27;&#x27;}`;
          break;
        }
      }

      obj.jsx = {
        name: jsxnode.openingElement.name.name,
        children: getChildJSXElements(jsxnode, name),
        props: getReactProps(jsxnode, name),
        state: {},
        methods: [],
        iterated: &#x27;higherOrder&#x27;,
        source: found.replace(&#x27;.&#x27;, &#x27;&#x27;),
      };

      const propsArr = obj.jsx.props;
      for (let i = 0; i &#x3c; propsArr.length; i++) {
        propsArr[i].value = propsArr[i].value.replace(param, `${obj.jsx.source}[i]`);
        for (const key in obj.variables) {
          if (propsArr[i].value.includes(key)) {
            propsArr[i].value = propsArr[i].value.replace(key, obj.variables[key]);
          }
        }
      }
    }
    return obj;
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.jsToAst" id="apidoc.element.react-monocle.reactParser.jsToAst">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>jsToAst
        <span class="apidocSignatureSpan">(js)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jsToAst(js) {
  const ast = acorn.parse(js, {
    plugins: { jsx: true },
  });
  if (ast.body.length === 0) throw new Error(&#x27;Empty AST input&#x27;);
  return ast;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.stringRegexHelper" id="apidoc.module.react-monocle.stringRegexHelper">module react-monocle.stringRegexHelper</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.stringRegexHelper.regexIndexOf" id="apidoc.element.react-monocle.stringRegexHelper.regexIndexOf">
        function <span class="apidocSignatureSpan">react-monocle.stringRegexHelper.</span>regexIndexOf
        <span class="apidocSignatureSpan">(string, regex, startpos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regexIndexOf(string, regex, startpos) {
  var indexOf = string.substring(startpos || 0).search(regex);
  return (indexOf &#x3e;= 0) ? (indexOf + (startpos || 0)) : indexOf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.stringRegexHelper.regexLastIndexOf" id="apidoc.element.react-monocle.stringRegexHelper.regexLastIndexOf">
        function <span class="apidocSignatureSpan">react-monocle.stringRegexHelper.</span>regexLastIndexOf
        <span class="apidocSignatureSpan">(string, regex, startpos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regexLastIndexOf(string, regex, startpos) {
    regex = (regex.global)
      ? regex
      : new RegExp(regex.source, &#x22;g&#x22; + (regex.ignoreCase ? &#x22;i&#x22; : &#x22;&#x22;) + (regex.multiLine ? &#x22;m&#x22; : &#x22;&#x22;));
    if(typeof (startpos) == &#x22;undefined&#x22;) {
        startpos = string.length;
    } else if(startpos &#x3c; 0) {
        startpos = 0;
    }
    var stringToWorkWith = string.substring(0, startpos + 1);
    var lastIndexOf = -1;
    let result = regex.exec(stringToWorkWith);
    while (result !== null) {
      lastIndexOf = result.index;
      regex.lastIndex = result.index + result[0].length;
      result = regex.exec(stringToWorkWith);
    }
    return lastIndexOf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
