<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/team-gryff/react-monocle#readme">react-monocle (v0.1.6)</a>
</h1>
<h4>A developer tool to visualize a React application's component hierarchy.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle">module react-monocle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery">
            function <span class="apidocSignatureSpan">react-monocle.</span>esquery
            <span class="apidocSignatureSpan">(ast, selector)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>esrecurse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>estraverse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>previewParser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>reactParser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.</span>stringRegexHelper</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.esquery">module react-monocle.esquery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.esquery">
            function <span class="apidocSignatureSpan">react-monocle.</span>esquery
            <span class="apidocSignatureSpan">(ast, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.match">
            function <span class="apidocSignatureSpan">react-monocle.esquery.</span>match
            <span class="apidocSignatureSpan">(ast, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.matches">
            function <span class="apidocSignatureSpan">react-monocle.esquery.</span>matches
            <span class="apidocSignatureSpan">(node, selector, ancestry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.parse">
            function <span class="apidocSignatureSpan">react-monocle.esquery.</span>parse
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esquery.query">
            function <span class="apidocSignatureSpan">react-monocle.esquery.</span>query
            <span class="apidocSignatureSpan">(ast, selector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.esrecurse">module react-monocle.esrecurse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esrecurse.Visitor">
            function <span class="apidocSignatureSpan">react-monocle.esrecurse.</span>Visitor
            <span class="apidocSignatureSpan">(visitor, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.esrecurse.visit">
            function <span class="apidocSignatureSpan">react-monocle.esrecurse.</span>visit
            <span class="apidocSignatureSpan">(node, visitor, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.estraverse">module react-monocle.estraverse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.Controller">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>Controller
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.attachComments">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>attachComments
            <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.cloneEnvironment">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>cloneEnvironment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.replace">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>replace
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.estraverse.traverse">
            function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>traverse
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.estraverse.</span>Syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.estraverse.</span>VisitorKeys</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">react-monocle.estraverse.</span>VisitorOption</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">react-monocle.estraverse.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.parser">module react-monocle.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.parser.SyntaxError">
            function <span class="apidocSignatureSpan">react-monocle.parser.</span>SyntaxError
            <span class="apidocSignatureSpan">(expected, found, offset, line, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.parser.parse">
            function <span class="apidocSignatureSpan">react-monocle.parser.</span>parse
            <span class="apidocSignatureSpan">(input, startRule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.parser.toSource">
            function <span class="apidocSignatureSpan">react-monocle.parser.</span>toSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.previewParser">module react-monocle.previewParser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.getComponentName">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>getComponentName
            <span class="apidocSignatureSpan">(bundle, startingIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.getDivs">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>getDivs
            <span class="apidocSignatureSpan">(modifiedBundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.modifyBundleFile">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyBundleFile
            <span class="apidocSignatureSpan">(bundlejs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.modifyInitialState">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyInitialState
            <span class="apidocSignatureSpan">(modifiedBundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.modifySetStateStrings">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifySetStateStrings
            <span class="apidocSignatureSpan">(bundleFilePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.modifyTestBundleFile">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyTestBundleFile
            <span class="apidocSignatureSpan">(bundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.queryES5Ast">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>queryES5Ast
            <span class="apidocSignatureSpan">(bundlejs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.queryES6Ast">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>queryES6Ast
            <span class="apidocSignatureSpan">(bundlejs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.structureInitialES5StateObj">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>structureInitialES5StateObj
            <span class="apidocSignatureSpan">(bundle, arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.previewParser.structureInitialES6StateObj">
            function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>structureInitialES6StateObj
            <span class="apidocSignatureSpan">(bundle, arr)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.reactParser">module react-monocle.reactParser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.componentChecker">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>componentChecker
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.forInFinder">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>forInFinder
            <span class="apidocSignatureSpan">(arr, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.forLoopFinder">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>forLoopFinder
            <span class="apidocSignatureSpan">(arr, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.getES5ReactComponents">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getES5ReactComponents
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.getES6ReactComponents">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getES6ReactComponents
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.getStatelessFunctionalComponents">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getStatelessFunctionalComponents
            <span class="apidocSignatureSpan">(ast, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.higherOrderFunctionFinder">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>higherOrderFunctionFinder
            <span class="apidocSignatureSpan">(arr, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.reactParser.jsToAst">
            function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>jsToAst
            <span class="apidocSignatureSpan">(js)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.react-monocle.stringRegexHelper">module react-monocle.stringRegexHelper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.stringRegexHelper.regexIndexOf">
            function <span class="apidocSignatureSpan">react-monocle.stringRegexHelper.</span>regexIndexOf
            <span class="apidocSignatureSpan">(string, regex, startpos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.react-monocle.stringRegexHelper.regexLastIndexOf">
            function <span class="apidocSignatureSpan">react-monocle.stringRegexHelper.</span>regexLastIndexOf
            <span class="apidocSignatureSpan">(string, regex, startpos)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle" id="apidoc.module.react-monocle">module react-monocle</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.esquery" id="apidoc.element.react-monocle.esquery">
        function <span class="apidocSignatureSpan">react-monocle.</span>esquery
        <span class="apidocSignatureSpan">(ast, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(ast, selector) {
    return match(ast, parse(selector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.esquery" id="apidoc.module.react-monocle.esquery">module react-monocle.esquery</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.esquery.esquery" id="apidoc.element.react-monocle.esquery.esquery">
        function <span class="apidocSignatureSpan">react-monocle.</span>esquery
        <span class="apidocSignatureSpan">(ast, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(ast, selector) {
    return match(ast, parse(selector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esquery.match" id="apidoc.element.react-monocle.esquery.match">
        function <span class="apidocSignatureSpan">react-monocle.esquery.</span>match
        <span class="apidocSignatureSpan">(ast, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(ast, selector) {
    var ancestry = [], results = [], altSubjects, i, l, k, m;
    if (!selector) { return results; }
    altSubjects = subjects(selector);
    estraverse.traverse(ast, {
        enter: function (node, parent) {
            if (parent != null) { ancestry.unshift(parent); }
            if (matches(node, selector, ancestry)) {
                if (altSubjects.length) {
                    for (i = 0, l = altSubjects.length; i &lt; l; ++i) {
                        if (matches(node, altSubjects[i], ancestry)) { results.push(node); }
                        for (k = 0, m = ancestry.length; k &lt; m; ++k) {
                            if (matches(ancestry[k], altSubjects[i], ancestry.slice(k + 1))) {
                                results.push(ancestry[k]);
                            }
                        }
                    }
                } else {+
                    results.push(node);
                }
            }
        },
        leave: function () { ancestry.shift(); }
    });
    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
result.css = findCSS(stringed, path.replace(/\/.*?\.html/, '').replace(/\/?.*?\.html/, ''));

return result;
}

function findCSS(str, relPath) {
if (relPath !== '') relPath = relPath + '/';
const styleTags = str.<span class="apidocCodeKeywordSpan">match</span>(/&lt;style&gt;(\n|.)*?(&lt;\/style&gt;)/g) || [&amp;#
x27;'];
const cssLinks = str.match(/&lt;link.*?css.*?&gt;/g);
if (!cssLinks &amp;&amp; !styleTags) return [];
if (!cssLinks) return styleTags;
return cssLinks.map(ele =&gt; {
  if (!ele) return;
  if (ele.search(/http/) !== -1) return ele;
  if (ele.search(/href(\s?)=(\s?)(\\?)('|")\/{2}/)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esquery.matches" id="apidoc.element.react-monocle.esquery.matches">
        function <span class="apidocSignatureSpan">react-monocle.esquery.</span>matches
        <span class="apidocSignatureSpan">(node, selector, ancestry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matches(node, selector, ancestry) {
    var path, ancestor, i, l, p;
    if (!selector) { return true; }
    if (!node) { return false; }
    if (!ancestry) { ancestry = []; }

    switch(selector.type) {
        case 'wildcard':
            return true;

        case 'identifier':
            return selector.value.toLowerCase() === node.type.toLowerCase();

        case 'field':
            path = selector.name.split('.');
            ancestor = ancestry[path.length - 1];
            return inPath(node, ancestor, path);

        case 'matches':
            for (i = 0, l = selector.selectors.length; i &lt; l; ++i) {
                if (matches(node, selector.selectors[i], ancestry)) { return true; }
            }
            return false;

        case 'compound':
            for (i = 0, l = selector.selectors.length; i &lt; l; ++i) {
                if (!matches(node, selector.selectors[i], ancestry)) { return false; }
            }
            return true;

        case 'not':
            for (i = 0, l = selector.selectors.length; i &lt; l; ++i) {
                if (matches(node, selector.selectors[i], ancestry)) { return false; }
            }
            return true;

        case 'child':
            if (matches(node, selector.right, ancestry)) {
                return matches(ancestry[0], selector.left, ancestry.slice(1));
            }
            return false;

        case 'descendant':
            if (matches(node, selector.right, ancestry)) {
                for (i = 0, l = ancestry.length; i &lt; l; ++i) {
                    if (matches(ancestry[i], selector.left, ancestry.slice(i + 1))) {
                        return true;
                    }
                }
            }
            return false;

        case 'attribute':
            p = getPath(node, selector.name);
            switch (selector.operator) {
                case null:
                case void 0:
                    return p != null;
                case '=':
                    switch (selector.value.type) {
                        case 'regexp': return selector.value.value.test(p);
                        case 'literal': return '' + selector.value.value === '' + p;
                        case 'type': return selector.value.value === typeof p;
                    }
                case '!=':
                    switch (selector.value.type) {
                        case 'regexp': return !selector.value.value.test(p);
                        case 'literal': return '' + selector.value.value !== '' + p;
                        case 'type': return selector.value.value !== typeof p;
                    }
                case '&lt;=': return p &lt;= selector.value.value;
                case '&lt;': return p &lt; selector.value.value;
                case '&gt;': return p &gt; selector.value.value;
                case '&gt;=': return p &gt;= selector.value.value;
            }

        case 'sibling':
            return matches(node, selector.right, ancestry) &amp;&amp;
                sibling(node, selector.left, ancestry) ||
                matches(node, selector.left, ancestry) &amp;&amp;
                sibling(node, selector.right, ancestry);

        case 'adjacent':
            return matches(node, selector.right, ancestry) &amp;&amp;
                adjacent(node, selector.left, ancestry) ||
                matches(node, selector.left, ancestry) &amp;&amp;
                adjacent(node, selector.right, ancestry);

        case 'nth-child':
            return matches(node, selector.right, ancestry) &amp;&amp;
                nthChild(node, ancestry, function (length) {
                    return selector.index.value - 1;
                });

        case 'nth-last-child':
            return matches(node, selector.right, ancestry) &amp;&amp;
                nthChild(node, ancestry, function (length) {
                    return length - selector.index.value;
                });

        case 'class':
            if(!node.type) return false;
            switch(selector.name.toLowerCase()){
                case 'statement':
                    if(node.type.slice(-9) === 'Statement') return true; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esquery.parse" id="apidoc.element.react-monocle.esquery.parse">
        function <span class="apidocSignatureSpan">react-monocle.esquery.</span>parse
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(selector) {
    return parser.parse(selector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return results;
}

/**
 * Parse a selector string and return its AST.
 */
function parse(selector) {
    return parser.<span class="apidocCodeKeywordSpan">parse</span>(selector);
}

/**
 * Query the code AST using the selector string.
 */
function query(ast, selector) {
    return match(ast, parse(selector));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esquery.query" id="apidoc.element.react-monocle.esquery.query">
        function <span class="apidocSignatureSpan">react-monocle.esquery.</span>query
        <span class="apidocSignatureSpan">(ast, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(ast, selector) {
    return match(ast, parse(selector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.esrecurse" id="apidoc.module.react-monocle.esrecurse">module react-monocle.esrecurse</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.esrecurse.Visitor" id="apidoc.element.react-monocle.esrecurse.Visitor">
        function <span class="apidocSignatureSpan">react-monocle.esrecurse.</span>Visitor
        <span class="apidocSignatureSpan">(visitor, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Visitor(visitor, options) {
    options = options || {};

    this.__visitor = visitor ||  this;
    this.__childVisitorKeys = options.childVisitorKeys
        ? assign({}, estraverse.VisitorKeys, options.childVisitorKeys)
        : estraverse.VisitorKeys;
    if (options.fallback === 'iteration') {
        this.__fallback = objectKeys;
    } else if (typeof options.fallback === 'function') {
        this.__fallback = options.fallback;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.esrecurse.visit" id="apidoc.element.react-monocle.esrecurse.visit">
        function <span class="apidocSignatureSpan">react-monocle.esrecurse.</span>visit
        <span class="apidocSignatureSpan">(node, visitor, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visit = function (node, visitor, options) {
    var v = new Visitor(visitor, options);
    v.visit(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        for (i = 0, iz = children.length; i &lt; iz; ++i) {
child = node[children[i]];
if (child) {
    if (isArray(child)) {
        for (j = 0, jz = child.length; j &lt; jz; ++j) {
            if (child[j]) {
                if (isNode(child[j]) || isProperty(type, children[i])) {
                    this.<span class="apidocCodeKeywordSpan">visit</span>(child[j]);
                }
            }
        }
    } else if (isNode(child)) {
        this.visit(child);
    }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.estraverse" id="apidoc.module.react-monocle.estraverse">module react-monocle.estraverse</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.Controller" id="apidoc.element.react-monocle.estraverse.Controller">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>Controller
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Controller() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.attachComments" id="apidoc.element.react-monocle.estraverse.attachComments">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>attachComments
        <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachComments(tree, providedComments, tokens) {
      // At first, we should calculate extended comment ranges.
  var comments = [], comment, len, i, cursor;

  if (!tree.range) {
    throw new Error('attachComments needs range information');
  }

      // tokens array is empty, we attach comments to tree as 'leadingComments'
  if (!tokens.length) {
    if (providedComments.length) {
      for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
          comment = deepCopy(providedComments[i]);
          comment.extendedRange = [0, tree.range[0]];
          comments.push(comment);
        }
      tree.leadingComments = comments;
    }
    return tree;
  }

  for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
    comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
  }

      // This is based on John Freeman's implementation.
  cursor = 0;
  traverse(tree, {
    enter(node) {
      var comment;

      while (cursor &lt; comments.length) {
          comment = comments[cursor];
          if (comment.extendedRange[1] &gt; node.range[0]) {
              break;
            }

          if (comment.extendedRange[1] === node.range[0]) {
              if (!node.leadingComments) {
                  node.leadingComments = [];
                }
              node.leadingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
        }

              // already out of owned node
      if (cursor === comments.length) {
          return VisitorOption.Break;
        }

      if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
          return VisitorOption.Skip;
        }
    },
  });

  cursor = 0;
  traverse(tree, {
    leave(node) {
      var comment;

      while (cursor &lt; comments.length) {
          comment = comments[cursor];
          if (node.range[1] &lt; comment.extendedRange[0]) {
              break;
            }

          if (node.range[1] === comment.extendedRange[0]) {
              if (!node.trailingComments) {
                  node.trailingComments = [];
                }
              node.trailingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
        }

              // already out of owned node
      if (cursor === comments.length) {
          return VisitorOption.Break;
        }

      if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
          return VisitorOption.Skip;
        }
    },
  });

  return tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.cloneEnvironment" id="apidoc.element.react-monocle.estraverse.cloneEnvironment">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>cloneEnvironment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneEnvironment = function () { return clone({}); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.replace" id="apidoc.element.react-monocle.estraverse.replace">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>replace
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(root, visitor) {
  var controller = new Controller();
  return controller.replace(root, visitor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Any character may appear in the form of an escape sequence.
*
* For portability, we also escape escape all control and non-ASCII
* characters. Note that "\0" and "\v" escape sequences are not used
* because JSHint does not like the first and IE the second.
*/
return '"' + s
 .<span class="apidocCodeKeywordSpan">replace</span>(/\\/g, '\\\\')  // backslash
 .replace(/"/g, '\\"')    // closing quote character
 .replace(/\x08/g, '\\b') // backspace
 .replace(/\t/g, '\\t')   // horizontal tab
 .replace(/\n/g, '\\n')   // line feed
 .replace(/\f/g, '\\f')   // form feed
 .replace(/\r/g, '\\r')   // carriage return
 .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.estraverse.traverse" id="apidoc.element.react-monocle.estraverse.traverse">
        function <span class="apidocSignatureSpan">react-monocle.estraverse.</span>traverse
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(root, visitor) {
  var controller = new Controller();
  return controller.traverse(root, visitor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * From a JS AST and a selector AST, collect all JS AST nodes that match the selector.
 */
function match(ast, selector) {
    var ancestry = [], results = [], altSubjects, i, l, k, m;
    if (!selector) { return results; }
    altSubjects = subjects(selector);
    estraverse.<span class="apidocCodeKeywordSpan">traverse</span>(ast, {
        enter: function (node, parent) {
            if (parent != null) { ancestry.unshift(parent); }
            if (matches(node, selector, ancestry)) {
                if (altSubjects.length) {
                    for (i = 0, l = altSubjects.length; i &lt; l; ++i) {
                        if (matches(node, altSubjects[i], ancestry)) { results.push(node); }
                        for (k = 0, m = ancestry.length; k &lt; m; ++k) {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.parser" id="apidoc.module.react-monocle.parser">module react-monocle.parser</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.parser.SyntaxError" id="apidoc.element.react-monocle.parser.SyntaxError">
        function <span class="apidocSignatureSpan">react-monocle.parser.</span>SyntaxError
        <span class="apidocSignatureSpan">(expected, found, offset, line, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SyntaxError = function (expected, found, offset, line, column) {
  function buildMessage(expected, found) {
    var expectedHumanized, foundHumanized;

    switch (expected.length) {
      case 0:
        expectedHumanized = "end of input";
        break;
      case 1:
        expectedHumanized = expected[0];
        break;
      default:
        expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
          + " or "
          + expected[expected.length - 1];
    }

    foundHumanized = found ? quote(found) : "end of input";

    return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
  }

  this.name = "SyntaxError";
  this.expected = expected;
  this.found = found;
  this.message = buildMessage(expected, found);
  this.offset = offset;
  this.line = line;
  this.column = column;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * handle these states.
 */
if (result === null || pos !== input.length) {
  var offset = Math.max(pos, rightmostFailuresPos);
  var found = offset &lt; input.length ? input.charAt(offset) : null;
  var errorPosition = computeErrorPosition();

  throw new this.<span class="apidocCodeKeywordSpan">SyntaxError</span>(
    cleanupExpected(rightmostFailuresExpected),
    found,
    offset,
    errorPosition.line,
    errorPosition.column
  );
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.parser.parse" id="apidoc.element.react-monocle.parser.parse">
        function <span class="apidocSignatureSpan">react-monocle.parser.</span>parse
        <span class="apidocSignatureSpan">(input, startRule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (input, startRule) {
  var parseFunctions = {
    "start": parse_start,
    "_": parse__,
    "identifierName": parse_identifierName,
    "binaryOp": parse_binaryOp,
    "selectors": parse_selectors,
    "selector": parse_selector,
    "sequence": parse_sequence,
    "atom": parse_atom,
    "wildcard": parse_wildcard,
    "identifier": parse_identifier,
    "attr": parse_attr,
    "attrOps": parse_attrOps,
    "attrEqOps": parse_attrEqOps,
    "attrName": parse_attrName,
    "attrValue": parse_attrValue,
    "string": parse_string,
    "number": parse_number,
    "path": parse_path,
    "type": parse_type,
    "regex": parse_regex,
    "field": parse_field,
    "negation": parse_negation,
    "matches": parse_matches,
    "firstChild": parse_firstChild,
    "lastChild": parse_lastChild,
    "nthChild": parse_nthChild,
    "nthLastChild": parse_nthLastChild,
    "class": parse_class
  };

  if (startRule !== undefined) {
    if (parseFunctions[startRule] === undefined) {
      throw new Error("Invalid rule name: " + quote(startRule) + ".");
    }
  } else {
    startRule = "start";
  }

  var pos = 0;
  var reportFailures = 0;
  var rightmostFailuresPos = 0;
  var rightmostFailuresExpected = [];
  var cache = {};

  function padLeft(input, padding, length) {
    var result = input;

    var padLength = length - input.length;
    for (var i = 0; i &lt; padLength; i++) {
      result = padding + result;
    }

    return result;
  }

  function escape(ch) {
    var charCode = ch.charCodeAt(0);
    var escapeChar;
    var length;

    if (charCode &lt;= 0xFF) {
      escapeChar = 'x';
      length = 2;
    } else {
      escapeChar = 'u';
      length = 4;
    }

    return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
  }

  function matchFailed(failure) {
    if (pos &lt; rightmostFailuresPos) {
      return;
    }

    if (pos &gt; rightmostFailuresPos) {
      rightmostFailuresPos = pos;
      rightmostFailuresExpected = [];
    }

    rightmostFailuresExpected.push(failure);
  }

  function parse_start() {
    var cacheKey = "start@" + pos;
    var cachedResult = cache[cacheKey];
    if (cachedResult) {
      pos = cachedResult.nextPos;
      return cachedResult.result;
    }

    var result0, result1, result2;
    var pos0, pos1;

    pos0 = pos;
    pos1 = pos;
    result0 = parse__();
    if (result0 !== null) {
      result1 = parse_selectors();
      if (result1 !== null) {
        result2 = parse__();
        if (result2 !== null) {
          result0 = [result0, result1, result2];
        } else {
          result0 = null;
          pos = pos1;
        }
      } else {
        result0 = null;
        pos = pos1;
      }
    } else {
      result0 = null;
      pos = pos1;
    }
    if (result0 !== null) {
      result0 = (function(offset, ss) { return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss }; })(pos0, result0[1]);
    }
    if (result0 === null) {
      pos = pos0;
    }
    if (result0 === null) {
      pos0 = pos;
      result0 = parse__();
      if (result0 !== null) {
        result0 = (function(offset) { return void 0; })(pos0);
      }
      if (result0 === null) {
        pos = pos0;
      }
    }

    cache[cacheKey] = {
      nextPos: pos,
      result:  result0
    };
    return result0;
  }

  function parse__() {
    var cacheKey = "_@" + pos;
    var cachedResult = cache[cacheKey];
    if (cachedResult) {
      pos = cachedResult.nextPos;
      return cachedResult.result;
    }

    var result0, result1;

    result0 = [];
    if (input.charCodeAt(pos) === 32) {
      result1 = " ";
      pos++;
    } else {
      result1 = null;
      if (reportFailures === 0) {
        matchFailed("\" \"");
      }
    }
    while (result1 !== null) {
      result0.push(result1);
      if (input.charCodeAt(pos) === 32) {
        result1 = " ";
        pos++;
      } else {
        result1 = null;
        if (reportFailures === 0) {
          matchFailed("\" \"");
        }
      }
    }

    cache[cacheKey ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return results;
}

/**
 * Parse a selector string and return its AST.
 */
function parse(selector) {
    return parser.<span class="apidocCodeKeywordSpan">parse</span>(selector);
}

/**
 * Query the code AST using the selector string.
 */
function query(ast, selector) {
    return match(ast, parse(selector));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.parser.toSource" id="apidoc.element.react-monocle.parser.toSource">
        function <span class="apidocSignatureSpan">react-monocle.parser.</span>toSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSource = function () { return this._source; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.previewParser" id="apidoc.module.react-monocle.previewParser">module react-monocle.previewParser</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.getComponentName" id="apidoc.element.react-monocle.previewParser.getComponentName">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>getComponentName
        <span class="apidocSignatureSpan">(bundle, startingIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getComponentName(bundle, startingIndex) {
  let bundleSearchIndicesMap = {};
  // get index of component declaration
  bundleSearchIndicesMap[regexLastIndexOf(bundle, /(var )?\w+\s*?=\s*(\(\d+\, )?_react(\d+\[\"\w+\"\])?.createClass/, startingIndex
)] = 'WEBPACKES5';
  // let's try ES6...
  bundleSearchIndicesMap[regexLastIndexOf(bundle, /(var )?\w+\s*?=\s*?function\s*?\(_(React\$)?Component\)/, startingIndex)] = '
WEBPACKES6';
  // let's try GULP
  bundleSearchIndicesMap[regexLastIndexOf(bundle, /var \w+ = React.createClass\({/, startingIndex)] = 'GULP';
  // let's try Rollup ex: var Slick = (function (superclass) {
  bundleSearchIndicesMap[regexLastIndexOf(bundle, /var \w+ = \(function \(superclass\) {/, startingIndex)] = 'ROLLUP';
  const targetIndex = Object.keys(bundleSearchIndicesMap)
  	.filter(index =&gt; index &gt;= 0)
  	.reduce((prev, curr) =&gt; {
  	  return Math.abs(curr-startingIndex) &lt; Math.abs(prev-startingIndex)
  	  	? curr
  	  	: prev;
  	});

  let componentMatch;
  switch(bundleSearchIndicesMap[targetIndex]) {
  	case 'WEBPACKES5':
  	  componentMatch = bundle.slice(targetIndex)
  	  	.match(/(var )?\w+\s*?=\s*(\(\d+\, )?_react(\d+\[\"\w+\"\])?.createClass/)
  	  break;
    case 'WEBPACKES6':
   	  componentMatch = bundle.slice(targetIndex)
  	    .match(/(var )?\w+\s*?=\s*?function\s*?\(_(React\$)?Component\)/)
   	  break;
    case 'GULP':
      componentMatch = bundle.slice(targetIndex)
        .match(/var \w+ = React.createClass\({/)
      break;
    case 'ROLLUP':
      componentMatch = bundle.slice(targetIndex)
        .match(/var \w+ = \(function \(superclass\) {/)
      break;
    default:
    	throw new Error('Unable to find component from bundle file');
  }

  // need to normalize component name (remove declarator ex. var, const)
  return componentMatch[0]
    .replace(/var |const /, '')
    .replace(/ /g, '')
    .split('=')[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.getDivs" id="apidoc.element.react-monocle.previewParser.getDivs">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>getDivs
        <span class="apidocSignatureSpan">(modifiedBundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDivs(modifiedBundle) {
  let index = modifiedBundle.indexOf('getElementById(', 0);
  let divsArr = [];
  while (index !== -1) {
    let openParenIdx = modifiedBundle.indexOf('(', index - 1);
    let currentIdx = openParenIdx + 1;
    const parensStack = ['('];
    while (parensStack.length !== 0) {
      if (modifiedBundle[currentIdx] === '(') parensStack.push(modifiedBundle[currentIdx]);
      if (modifiedBundle[currentIdx] === ')') parensStack.pop();
      currentIdx++;
    }
    divsArr.push(modifiedBundle.slice(openParenIdx + 2, currentIdx - 2));
    index = modifiedBundle.indexOf('getElementById(', index + 1);
  }
  divsArr = divsArr.map(ele =&gt; {
    return `&lt;div id='${ele}'&gt;&lt;/div&gt;`;
  });
  const uniqueArr = [];
  for (let i = 0; i &lt; divsArr.length; i++) {
    if (uniqueArr.indexOf(divsArr[i]) &lt; 0) {
      uniqueArr.push(divsArr[i]);
    }
  }
  return uniqueArr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.modifyBundleFile" id="apidoc.element.react-monocle.previewParser.modifyBundleFile">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyBundleFile
        <span class="apidocSignatureSpan">(bundlejs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modifyBundleFile(bundlejs) {
  const bundle = fs.readFileSync(bundlejs, { encoding: 'utf-8' });
  if (bundle.length === 0) throw new Error('Empty AST input');
  const searchState = /this.setState/g;
  const wrappedFunc = 'wrapper(this.setState)';
  const searchElem = /(getElementById\([\'\"])\w+[\'\"]/;
  const newMount = 'getElementById("preview"';
  const replacedState = bundle.replace(searchState, wrappedFunc);
  return replacedState.replace(searchElem, newMount);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.modifyInitialState" id="apidoc.element.react-monocle.previewParser.modifyInitialState">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyInitialState
        <span class="apidocSignatureSpan">(modifiedBundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modifyInitialState(modifiedBundle) {
  let index = -1;
  if (modifiedBundle.indexOf('_this.state') &gt;= 0) {
    // do webpack
    index = modifiedBundle.indexOf('_this.state', 0);
  } else if (modifiedBundle.indexOf('getInitialState() {', 0) &gt;= 0) {
    // do gulp
    index = modifiedBundle.indexOf('getInitialState() {', 0) + 19;
  } else if (modifiedBundle.indexOf('this.state', 0) &gt;= 0) {
    // do rollup
    index = modifiedBundle.indexOf('this.state = {');
  } else {
    throw new Error('Unable to find component initial state');
  }

  while (index !== -1) {
    let openBraceIdx = modifiedBundle.indexOf('{', index); // looking for index of follow brace, after return statement
    let currentIdx = openBraceIdx + 1;
    const parensStack = ['{'];
    while (parensStack.length !== 0) {
      if (modifiedBundle[currentIdx] === '{') parensStack.push(modifiedBundle[currentIdx]);
      if (modifiedBundle[currentIdx] === '}') parensStack.pop();
      currentIdx++;
    }

    let injection,
        componentName = getComponentName(modifiedBundle, index),
        stateStr = modifiedBundle.slice(openBraceIdx, currentIdx);
    if (modifiedBundle.indexOf('_this.state', 0) &gt;= 0) {
      injection = `_this.state = grabInitialState('${componentName}', ${stateStr}),`;
    } else if (modifiedBundle.indexOf('getInitialState() {', 0) &gt;= 0) {
      injection = `return grabInitialState('${componentName}', ${stateStr}),`;
    } else if (modifiedBundle.indexOf('this.state = {', 0) &gt;= 0) {
      injection = `this.state = grabInitialState('${componentName}', ${stateStr}),`;
    }

    modifiedBundle = modifiedBundle.slice(0, index) + injection + modifiedBundle.slice(currentIdx + 1);

    // need to take into account that length of bundle now changes since injected wrapper string length can be different than original
    const oldLength = currentIdx - index;
    const newLength = injection.length;

    if (modifiedBundle.indexOf('_this.state') &gt;= 0) {
      index = modifiedBundle.indexOf('_this.state', index + 1 + newLength - oldLength);
    } else if (modifiedBundle.indexOf('getInitialState() {') &gt;= 0) {
      index = modifiedBundle.indexOf('getInitialState() {', index + 1 + newLength - oldLength);
    } else if (modifiedBundle.indexOf('this.state = grabInitialState') &gt;= 0) {
      index = modifiedBundle.indexOf('this.state = grabInitialState', index + 1 + newLength - oldLength);
    } else {
      throw new Error('Unable to find next initial state index');
    }
  }
  return modifiedBundle;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.modifySetStateStrings" id="apidoc.element.react-monocle.previewParser.modifySetStateStrings">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifySetStateStrings
        <span class="apidocSignatureSpan">(bundleFilePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modifySetStateStrings(bundleFilePath) {
  let bundle;
  try {
    bundle = fs.readFileSync(bundleFilePath, { encoding: 'utf-8' });
  } catch(error) {
    throw new Error('Invalid bundle file path specified. Please enter a valid path to your app\'s bundle file');
  }

  if (bundle.length == 0) throw new Error('Bundle string is empty, provide valid bundle string input');

  console.log('Starting to strip comments from bundle file...');
  const start = Date.now();
  let modifiedBundle = strip(bundle.slice());
  console.log(`Took ${(Date.now() - start) / 1000} seconds to strip comments input bundle file`);
  let index = modifiedBundle.indexOf('this.setState', 0);
  while (index !== -1) {
    let openBraceIdx = modifiedBundle.indexOf('{', index);
    let currentIdx = openBraceIdx + 1;
    const parensStack = ['{'];
    while (parensStack.length !== 0) {
      if (modifiedBundle[currentIdx] === '{') parensStack.push(modifiedBundle[currentIdx]);
      if (modifiedBundle[currentIdx] === '}') parensStack.pop();
      currentIdx++;
    }
    const stateStr = modifiedBundle.slice(openBraceIdx, currentIdx);
    const functionStartIdx = currentIdx;
    parensStack.push('(');
    while (parensStack.length !== 0) {
      if (modifiedBundle[currentIdx] === '(') parensStack.push(modifiedBundle[currentIdx]);
      if (modifiedBundle[currentIdx] === ')') parensStack.pop();
      currentIdx++;
    }
    currentIdx--;
    const callbackStr = modifiedBundle.slice(functionStartIdx, currentIdx);
    const injection = `wrapper('${getComponentName(modifiedBundle, index)}',this)(${ stateStr }${ callbackStr })`;
    modifiedBundle = modifiedBundle.slice(0, index) + injection + modifiedBundle.slice(currentIdx + 1);
    // need to take into account that length of bundle now changes since injected wrapper string length can be different than original
    const oldLength = currentIdx - index;
    const newLength = injection.length;

    index = modifiedBundle.indexOf('this.setState', index+1+newLength-oldLength);
  }
  return modifiedBundle;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.modifyTestBundleFile" id="apidoc.element.react-monocle.previewParser.modifyTestBundleFile">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>modifyTestBundleFile
        <span class="apidocSignatureSpan">(bundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modifyTestBundleFile(bundle) {
  if (bundle.length === 0) throw new Error('Empty AST input');
  const searchState = /this.setState/g;
  const wrappedFunc = 'wrapper(this.setState)';
  const searchElem = /(getElementById\([\'\"])\w+[\'\"]/;
  const newMount = 'getElementById("preview"';
  const replacedState = bundle.replace(searchState, wrappedFunc);
  return replacedState.replace(searchElem, newMount);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.queryES5Ast" id="apidoc.element.react-monocle.previewParser.queryES5Ast">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>queryES5Ast
        <span class="apidocSignatureSpan">(bundlejs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queryES5Ast(bundlejs) {
  if (!bundlejs) throw new Error('Empty bundle file input');
  const bundle = fs.readFileSync(bundlejs, { encoding: 'utf-8' });
  const ast = acorn.parse(bundle);
  if (ast.body.length === 0) throw new Error('Empty AST input');
  const parseInfo = esquery.parse('[id.name="getInitialState"]');
  const match = esquery.match(ast, parseInfo);
  const finalStateArr = [];
  if (match.length === 0) return {};
  match.map(ele =&gt; {
    const valueObj = {};
    ele.body.body.map(index =&gt; {
      if (index.type === 'ReturnStatement') {
        index.argument.properties.map(node =&gt; {
          if (node.value.hasOwnProperty('value')) {
            valueObj[node.key.name] = node.value.value;
          } else if (node.value.hasOwnProperty('name')) {
            valueObj[node.key.name] = node.value.name;
          } else if (node.value.hasOwnProperty('elements')) {
            valueObj[node.key.name] = node.value.elements;
          }
        });
        finalStateArr.push(valueObj);
      }
    });
  });
  return structureInitialES5StateObj(bundlejs, finalStateArr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.queryES6Ast" id="apidoc.element.react-monocle.previewParser.queryES6Ast">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>queryES6Ast
        <span class="apidocSignatureSpan">(bundlejs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queryES6Ast(bundlejs) {
  if (!bundlejs) throw new Error('Empty bundle file input');
  const bundle = fs.readFileSync(bundlejs, { encoding: 'utf-8' });
  const ast = acorn.parse(bundle);
  if (ast.body.length === 0) throw new Error('Empty AST input');
  const parseInfo = esquery.parse('ExpressionStatement');
  const match = esquery.match(ast, parseInfo);
  const finalStateArr = [];
  if (match.length === 0) return {};
  match.map(ele =&gt; {
    const valueObj = {};
    if (ele.expression.left) {
      if (ele.expression.left.object) {
        if (ele.expression.left.object.name === '_this') {
          const valueNode = ele.expression.right.properties;
          valueNode.map(node =&gt; {
            const finalValArr = [];
            if (node.value.elements) {
              node.value.elements.map(index =&gt; {
                finalValArr.push(index.value);
              });
            }
            valueObj[node.key.name] = node.value.value || finalValArr;
          });
          finalStateArr.push(valueObj);
        }
      }
    }
  });
  return structureInitialES6StateObj(bundle, finalStateArr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.structureInitialES5StateObj" id="apidoc.element.react-monocle.previewParser.structureInitialES5StateObj">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>structureInitialES5StateObj
        <span class="apidocSignatureSpan">(bundle, arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function structureInitialES5StateObj(bundle, arr) {
  if (arr.length === 0) return {};
  let initialStateIndex = bundle.indexOf('getInitialState()', 0);
  const objForReduxStore = {};
  for (let i = 0; i &lt; arr.length; i++) {
    const arrOfStateObjs = [];
    for (const key in arr[i]) {
      arrOfStateObjs.push({
        name: key,
        value: arr[i][key],
      });
      objForReduxStore[getComponentName(bundle, initialStateIndex)] = arrOfStateObjs;
    }
    initialStateIndex = bundle.indexOf('getInitialState()', initialStateIndex + 1);
  }
  return objForReduxStore;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.previewParser.structureInitialES6StateObj" id="apidoc.element.react-monocle.previewParser.structureInitialES6StateObj">
        function <span class="apidocSignatureSpan">react-monocle.previewParser.</span>structureInitialES6StateObj
        <span class="apidocSignatureSpan">(bundle, arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function structureInitialES6StateObj(bundle, arr) {
  if (arr.length === 0) return {};
  let initialStateIndex = bundle.indexOf('_this.state', 0);
  const objForReduxStore = {};
  for (let i = 0; i &lt; arr.length; i++) {
    const arrOfStateObjs = [];
    for (const key in arr[i]) {
      arrOfStateObjs.push({
        name: key,
        value: arr[i][key],
      });
      objForReduxStore[getComponentName(bundle, initialStateIndex)] = arrOfStateObjs;
    }
    initialStateIndex = bundle.indexOf('_this.state', initialStateIndex + 1);
  }
  return objForReduxStore;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.reactParser" id="apidoc.module.react-monocle.reactParser">module react-monocle.reactParser</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.componentChecker" id="apidoc.element.react-monocle.reactParser.componentChecker">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>componentChecker
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function componentChecker(ast) {
  for (let i = 0; i &lt; ast.body.length; i++) {
    if (ast.body[i].type === 'ClassDeclaration') return 'ES6';
    if (ast.body[i].type === 'ExportDefaultDeclaration' &amp;&amp; ast.body[i].declaration.type === 'ClassDeclaration') return 'ES6';
    if (ast.body[i].type === 'VariableDeclaration' &amp;&amp; ast.body[i].declarations[0].init
     &amp;&amp; ast.body[i].declarations[0].init.callee
    &amp;&amp; ast.body[i].declarations[0].init.callee.object &amp;&amp; ast.body[i].declarations[0].init.callee.object.name === 'React'
    &amp;&amp; ast.body[i].declarations[0].init.callee.property.name === 'createClass') return 'ES5'
  }
  return 'SFC';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function d3DataBuilder(obj) {
if (!obj.ENTRY) throw new Error('Entry component not found');
const formatted = {};

// parsing AST into formatted objects based on ES5/ES6 syntax
for (const key in obj) {
  if (key === 'ENTRY') continue;
  const componentChecker = reactParser.<span class="apidocCodeKeywordSpan">componentChecker</span>(obj[key]);
  // componentChecker returns true for es6 classes, false for everything else
  if (componentChecker === 'ES6') formatted[key] = reactParser.getES6ReactComponents(obj[key]);
  else if (componentChecker === 'ES5') formatted[key] = reactParser.getES5ReactComponents(obj[key]);
  else formatted[key] = reactParser.getStatelessFunctionalComponents(obj[key], key)
}

for (const key in formatted) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.forInFinder" id="apidoc.element.react-monocle.reactParser.forInFinder">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>forInFinder
        <span class="apidocSignatureSpan">(arr, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forInFinder(arr, name) {
  const result = arr.map(ele =&gt; {
    const jsxnode = esquery(ele, 'JSXElement')[0];
    const obj = {};
    obj.variables = {};
    esquery(ele, 'VariableDeclarator').forEach(vars =&gt; {
      if (vars.id.name !== 'i' &amp;&amp; vars.init) {
        obj.variables[vars.id.name] = escodegen.generate(vars.init).replace('this.', '');
      }
    });
    if (ele.left.declarations) obj.variables[ele.left.declarations[0].id.name] = '[key]';
    else if (ele.left.type === 'Identifier') obj.variables[ele.left.name] = '[key]';

    if (jsxnode &amp;&amp; htmlElements.indexOf(jsxnode.openingElement.name.name)) {
      let current = ele.right;
      let found;
      while (current &amp;&amp; current.property) {
        found = `.${current.property.name}${found || ''}`;
        current = current.object;
        if (current.type === 'Identifier') {
          found = `.${current.name}${found || ''}`;
          break;
        }
      }

      obj.jsx = {
        name: jsxnode.openingElement.name.name,
        children: getChildJSXElements(jsxnode, name),
        props: getReactProps(jsxnode, name),
        state: {},
        methods: [],
        iterated: 'forIn',
        source: found.replace('.', ''),
      };
      const propsArr = obj.jsx.props;
      for (let i = 0; i &lt; propsArr.length; i++) {
        for (const key in obj.variables) {
          if (propsArr[i].value.includes(key)) {
            if (obj.variables[key] === '[key]') propsArr[i].value = propsArr[i].value.replace(`.${key}`, obj.variables[key]);
            else propsArr[i].value = propsArr[i].value.replace(key, obj.variables[key]);
          }
        }
      }
    }
    return obj;
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.forLoopFinder" id="apidoc.element.react-monocle.reactParser.forLoopFinder">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>forLoopFinder
        <span class="apidocSignatureSpan">(arr, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forLoopFinder(arr, name) {
  const result = arr.map(ele =&gt; {
    const jsxnode = esquery(ele, 'JSXElement')[0];
    const obj = {};
    obj.variables = {};

    // finding variables in case information was reassigned
    esquery(ele, 'VariableDeclarator').forEach(vars =&gt; {
      if (vars.id.name !== 'i' &amp;&amp; vars.init) {
        obj.variables[vars.id.name] = escodegen.generate(vars.init).replace('this.', '').replace('.length', '');
      }
    });

    // defaulting each iteration to be represented by 'i'
    if (ele.init.declarations) obj.variables[ele.init.declarations[0].id.name] = '[i]';
    else if (ele.init.type === 'AssignmentExpression') obj.variables[ele.init.left.name] = '[i]';

    // building the object name
    if (jsxnode &amp;&amp; htmlElements.indexOf(jsxnode.openingElement.name.name)) {
      let current = ele.test.right;
      let found;
      while (current &amp;&amp; current.property) {
        found = `.${current.property.name}${found || ''}`;
        current = current.object;
        if (current.type === 'Identifier') {
          found = `.${current.name}${found || ''}`;
          break;
        }
      }

      obj.jsx = {
        name: jsxnode.openingElement.name.name,
        children: getChildJSXElements(jsxnode, name),
        props: getReactProps(jsxnode, name),
        state: {},
        methods: [],
        iterated: 'forLoop',
        source: found.replace('.', '').replace('.length', ''),
      };

      // replacing variables with their properties
      const propsArr = obj.jsx.props;
      for (let i = 0; i &lt; propsArr.length; i++) {
        for (const key in obj.variables) {
          if (propsArr[i].value.includes(key)) {
            if (obj.variables[key] === '[i]') propsArr[i].value = propsArr[i].value.replace(`.${key}`, obj.variables[key]);
            else propsArr[i].value = propsArr[i].value.replace(key, obj.variables[key]);
          }
        }
      }
    }
    return obj;
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.getES5ReactComponents" id="apidoc.element.react-monocle.reactParser.getES5ReactComponents">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getES5ReactComponents
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getES5ReactComponents(ast) {
  const output = {
    name: '',
    state: {},
    props: {},
    methods: [],
    children: [],
  };
  let iter = [];
  let topJsxComponent;
  let outside;
  const checker = {};
  esrecurse.visit(ast, {
    VariableDeclarator(node) {
      topJsxComponent = node.id.name;
      this.visitChildren(node);
    },
    MemberExpression(node) {
      if (node.property &amp;&amp; node.property.name === 'createClass') {
        output.name = topJsxComponent;
      }
      this.visitChildren(node);
    },
    ObjectExpression(node) {
      node.properties.forEach(prop =&gt; {
        if (reactMethods.indexOf(prop.key.name) &lt; 0
          &amp;&amp; prop.value.type === 'FunctionExpression') {
          output.methods.push(prop.key.name);
        }
      });
      this.visitChildren(node);
    },
    JSXElement(node) {
      output.children = getChildJSXElements(node, output.name);
      output.props = getReactProps(node, output.name);
      if (htmlElements.indexOf(node.openingElement.name.name) &lt; 0) {
        outside = {
          name: node.openingElement.name.name,
          children: getChildJSXElements(node, output.name),
          props: getReactProps(node, output.name),
          state: {},
          methods: [],
        };
      }
    },
  });

  const forIn = esquery(ast, 'ForInStatement').filter(ele =&gt; {
    const searched = bfs(ele).filter(n =&gt; {
      return n.type === 'JSXElement';
    });
    return searched.length &gt; 0;
  });
  if (forIn.length &gt; 0) iter = iter.concat(forInFinder(forIn, output.name));

  const forLoop = esquery(ast, 'ForStatement').filter(ele =&gt; {
    const searched = bfs(ele).filter(n =&gt; {
      return n.type === 'JSXElement';
    });
    return searched.length &gt; 0;
  });
  if (forLoop.length &gt; 0) iter = iter.concat(forLoopFinder(forLoop, output.name));

  const higherOrderFunc = esquery(ast, 'CallExpression').filter(ele =&gt; {
    let higherOrderChecker = false;
    const searched = bfs(ele).filter(n =&gt; {
      return n.type === 'JSXElement';
    });
    if (ele.callee.property &amp;&amp; ele.callee.property.name.match(/(map|forEach|filter|reduce)/)) {
      higherOrderChecker = ele.callee.property.name.match(/(map|forEach|filter|reduce)/);
    }
    return searched.length &gt; 0 &amp;&amp; higherOrderChecker;
  });
  if (higherOrderFunc.length &gt; 0) iter = iter.concat(higherOrderFunctionFinder(higherOrderFunc, output.name));

  if (outside) output.children.push(outside);
  output.children.forEach((ele, i) =&gt; {
    checker[ele.name] = i;
  });

  for (let i = 0; i &lt; iter.length; i++) {
    if (checker.hasOwnProperty(iter[i].jsx.name)) {
      output.children[checker[iter[i].jsx.name]] = iter[i].jsx;
    }
  }

  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// parsing AST into formatted objects based on ES5/ES6 syntax
for (const key in obj) {
  if (key === 'ENTRY') continue;
  const componentChecker = reactParser.componentChecker(obj[key]);
  // componentChecker returns true for es6 classes, false for everything else
  if (componentChecker === 'ES6') formatted[key] = reactParser.getES6ReactComponents(obj[key]);
  else if (componentChecker === 'ES5') formatted[key] = reactParser.<span class="apidocCodeKeywordSpan">getES5ReactComponents
</span>(obj[key]);
  else formatted[key] = reactParser.getStatelessFunctionalComponents(obj[key], key)
}

for (const key in formatted) {
  formatted[key].children.forEach(ele =&gt; {
    if (Array.isArray(ele.props)) {
      ele.props.forEach((propped, i) =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.getES6ReactComponents" id="apidoc.element.react-monocle.reactParser.getES6ReactComponents">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getES6ReactComponents
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getES6ReactComponents(ast) {
  const output = {
    name: '',
    props: {},
    state: {},
    methods: [],
    children: [],
  };
  let iter = [];
  let outside;
  const checker = {};
  esrecurse.visit(ast, {
    ClassDeclaration(node) {
      if (isES6ReactComponent(node)) {
        output.name = node.id.name;
        this.visitChildren(node);
      }
    },
    MethodDefinition(node) {
      if (reactMethods.indexOf(node.key.name) &lt; 0) output.methods.push(node.key.name);
      this.visitChildren(node);
    },
    // ExpressionStatement(node) {
    //   if (node.expression.left &amp;&amp; node.expression.left.property &amp;&amp; node.expression.left.property.name === 'state') {
    //     output.state = getReactStates(node.expression.right);
    //   }
    //   this.visitChildren(node);
    // },
    JSXElement(node) {
      // TODO: DO STUFF WITH JSX AFTER FINDING STUFF BOI
      output.children = getChildJSXElements(node, output.name);
      output.props = getReactProps(node, output.name);
      if (htmlElements.indexOf(node.openingElement.name.name) &lt; 0) {
        outside = {
          name: node.openingElement.name.name,
          children: getChildJSXElements(node, output.name),
          props: getReactProps(node, output.name),
          state: {},
          methods: [],
        };
      }
      const forIn = esquery(ast, 'ForInStatement').filter(ele =&gt; {
        const searched = bfs(ele).filter(n =&gt; {
          return n.type === 'JSXElement';
        });
        return searched.length &gt; 0;
      });
      if (forIn.length &gt; 0) iter = iter.concat(forInFinder(forIn, output.name));

      const forLoop = esquery(ast, 'ForStatement').filter(ele =&gt; {
        const searched = bfs(ele).filter(n =&gt; {
          return n.type === 'JSXElement';
        });
        return searched.length &gt; 0;
      });
      if (forLoop.length &gt; 0) iter = iter.concat(forLoopFinder(forLoop, output.name));

      const higherOrderFunc = esquery(ast, 'CallExpression').filter(ele =&gt; {
        let higherOrderChecker = false;
        const searched = bfs(ele).filter(n =&gt; {
          return n.type === 'JSXElement';
        });
        if (ele.callee.property &amp;&amp; ele.callee.property.name.match(/(map|forEach|filter|reduce)/)) {
          higherOrderChecker = ele.callee.property.name.match(/(map|forEach|filter|reduce)/);
        }
        return searched.length &gt; 0 &amp;&amp; higherOrderChecker;
      });
      if (higherOrderFunc.length &gt; 0) iter = iter.concat(higherOrderFunctionFinder(higherOrderFunc, output.name));
    },
  });

  if (outside) output.children.push(outside);
  output.children.forEach((ele, i) =&gt; {
    checker[ele.name] = i;
  });

  for (let i = 0; i &lt; iter.length; i++) {
    if (checker.hasOwnProperty(iter[i].jsx.name)) {
      output.children[checker[iter[i].jsx.name]] = iter[i].jsx;
    }
  }
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const formatted = {};

// parsing AST into formatted objects based on ES5/ES6 syntax
for (const key in obj) {
  if (key === 'ENTRY') continue;
  const componentChecker = reactParser.componentChecker(obj[key]);
  // componentChecker returns true for es6 classes, false for everything else
  if (componentChecker === 'ES6') formatted[key] = reactParser.<span class="apidocCodeKeywordSpan">getES6ReactComponents
</span>(obj[key]);
  else if (componentChecker === 'ES5') formatted[key] = reactParser.getES5ReactComponents(obj[key]);
  else formatted[key] = reactParser.getStatelessFunctionalComponents(obj[key], key)
}

for (const key in formatted) {
  formatted[key].children.forEach(ele =&gt; {
    if (Array.isArray(ele.props)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.getStatelessFunctionalComponents" id="apidoc.element.react-monocle.reactParser.getStatelessFunctionalComponents">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>getStatelessFunctionalComponents
        <span class="apidocSignatureSpan">(ast, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStatelessFunctionalComponents(ast, name) {
  const output = {
    name: name,
    state: {},
    props: {},
    methods: [],
    children: [],
  };

  let iter = [];
  let outside;
  const checker = {};
  esrecurse.visit(ast, {
    ObjectExpression(node) {
      node.properties.forEach(prop =&gt; {
        if (reactMethods.indexOf(prop.key.name) &lt; 0
          &amp;&amp; prop.value.type === 'FunctionExpression') {
          output.methods.push(prop.key.name);
        }
      });
      this.visitChildren(node);
    },
    JSXElement(node) {
      output.children = getChildJSXElements(node, output.name);
      output.props = getReactProps(node, output.name);
      if (htmlElements.indexOf(node.openingElement.name.name) &lt; 0) {
        outside = {
          name: node.openingElement.name.name,
          children: getChildJSXElements(node, output.name),
          props: getReactProps(node, output.name),
          state: {},
          methods: [],
        };
      }
    },
  });

  const forIn = esquery(ast, 'ForInStatement').filter(ele =&gt; {
    const searched = bfs(ele).filter(n =&gt; {
      return n.type === 'JSXElement';
    });
    return searched.length &gt; 0;
  });
  if (forIn.length &gt; 0) iter = iter.concat(forInFinder(forIn, output.name));

  const forLoop = esquery(ast, 'ForStatement').filter(ele =&gt; {
    const searched = bfs(ele).filter(n =&gt; {
      return n.type === 'JSXElement';
    });
    return searched.length &gt; 0;
  });
  if (forLoop.length &gt; 0) iter = iter.concat(forLoopFinder(forLoop, output.name));

  const higherOrderFunc = esquery(ast, 'CallExpression').filter(ele =&gt; {
    let higherOrderChecker = false;
    const searched = bfs(ele).filter(n =&gt; {
      return n.type === 'JSXElement';
    });
    if (ele.callee.property &amp;&amp; ele.callee.property.name.match(/(map|forEach|filter|reduce)/)) {
      higherOrderChecker = ele.callee.property.name.match(/(map|forEach|filter|reduce)/);
    }
    return searched.length &gt; 0 &amp;&amp; higherOrderChecker;
  });
  if (higherOrderFunc.length &gt; 0) iter = iter.concat(higherOrderFunctionFinder(higherOrderFunc, output.name));

  if (outside) output.children.push(outside);
  output.children.forEach((ele, i) =&gt; {
    checker[ele.name] = i;
  });

  for (let i = 0; i &lt; iter.length; i++) {
    if (checker.hasOwnProperty(iter[i].jsx.name)) {
      output.children[checker[iter[i].jsx.name]] = iter[i].jsx;
    }
  }
  return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// parsing AST into formatted objects based on ES5/ES6 syntax
for (const key in obj) {
  if (key === 'ENTRY') continue;
  const componentChecker = reactParser.componentChecker(obj[key]);
  // componentChecker returns true for es6 classes, false for everything else
  if (componentChecker === 'ES6') formatted[key] = reactParser.getES6ReactComponents(obj[key]);
  else if (componentChecker === 'ES5') formatted[key] = reactParser.getES5ReactComponents(obj[key]);
  else formatted[key] = reactParser.<span class="apidocCodeKeywordSpan">getStatelessFunctionalComponents</span>(obj[key], key)
}

for (const key in formatted) {
  formatted[key].children.forEach(ele =&gt; {
    if (Array.isArray(ele.props)) {
      ele.props.forEach((propped, i) =&gt; {
        if (typeof propped.value === 'object' &amp;&amp; propped.value.name &amp;&amp; propped.value.children) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.higherOrderFunctionFinder" id="apidoc.element.react-monocle.reactParser.higherOrderFunctionFinder">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>higherOrderFunctionFinder
        <span class="apidocSignatureSpan">(arr, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function higherOrderFunctionFinder(arr, name) {
  const result = arr.map(ele =&gt; {
    // since every higher order function will have some parameter
    // will be used to replace with what it actually is
    const param = ele.arguments[0].params[0].name;
    const jsxnode = esquery(ele, 'JSXElement')[0];
    const obj = {};
    obj.variables = {};
    esquery(ele, 'VariableDeclarator').forEach(vars =&gt; {
      obj.variables[vars.id.name] = escodegen.generate(vars.init);
    });

    if (jsxnode &amp;&amp; htmlElements.indexOf(jsxnode.openingElement.name.name)) {
      let current = ele.callee.object;
      let found;
      while (current &amp;&amp; current.property) {
        found = `.${current.property.name}${found || ''}`;
        current = current.object;
        if (current.type === 'Identifier') {
          found = `.${current.name}${found || ''}`;
          break;
        }
      }

      obj.jsx = {
        name: jsxnode.openingElement.name.name,
        children: getChildJSXElements(jsxnode, name),
        props: getReactProps(jsxnode, name),
        state: {},
        methods: [],
        iterated: 'higherOrder',
        source: found.replace('.', ''),
      };

      const propsArr = obj.jsx.props;
      for (let i = 0; i &lt; propsArr.length; i++) {
        propsArr[i].value = propsArr[i].value.replace(param, `${obj.jsx.source}[i]`);
        for (const key in obj.variables) {
          if (propsArr[i].value.includes(key)) {
            propsArr[i].value = propsArr[i].value.replace(key, obj.variables[key]);
          }
        }
      }
    }
    return obj;
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.reactParser.jsToAst" id="apidoc.element.react-monocle.reactParser.jsToAst">
        function <span class="apidocSignatureSpan">react-monocle.reactParser.</span>jsToAst
        <span class="apidocSignatureSpan">(js)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jsToAst(js) {
  const ast = acorn.parse(js, {
    plugins: { jsx: true },
  });
  if (ast.body.length === 0) throw new Error('Empty AST input');
  return ast;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.react-monocle.stringRegexHelper" id="apidoc.module.react-monocle.stringRegexHelper">module react-monocle.stringRegexHelper</a></h1>


    <h2>
        <a href="#apidoc.element.react-monocle.stringRegexHelper.regexIndexOf" id="apidoc.element.react-monocle.stringRegexHelper.regexIndexOf">
        function <span class="apidocSignatureSpan">react-monocle.stringRegexHelper.</span>regexIndexOf
        <span class="apidocSignatureSpan">(string, regex, startpos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regexIndexOf(string, regex, startpos) {
  var indexOf = string.substring(startpos || 0).search(regex);
  return (indexOf &gt;= 0) ? (indexOf + (startpos || 0)) : indexOf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.react-monocle.stringRegexHelper.regexLastIndexOf" id="apidoc.element.react-monocle.stringRegexHelper.regexLastIndexOf">
        function <span class="apidocSignatureSpan">react-monocle.stringRegexHelper.</span>regexLastIndexOf
        <span class="apidocSignatureSpan">(string, regex, startpos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regexLastIndexOf(string, regex, startpos) {
    regex = (regex.global)
      ? regex
      : new RegExp(regex.source, "g" + (regex.ignoreCase ? "i" : "") + (regex.multiLine ? "m" : ""));
    if(typeof (startpos) == "undefined") {
        startpos = string.length;
    } else if(startpos &lt; 0) {
        startpos = 0;
    }
    var stringToWorkWith = string.substring(0, startpos + 1);
    var lastIndexOf = -1;
    let result = regex.exec(stringToWorkWith);
    while (result !== null) {
      lastIndexOf = result.index;
      regex.lastIndex = result.index + result[0].length;
      result = regex.exec(stringToWorkWith);
    }
    return lastIndexOf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>